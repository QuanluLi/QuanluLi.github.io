<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP协议的流量控控制]]></title>
    <url>%2F2019%2F03%2F28%2FTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[TCP协议的流量控控制 为什么需要流量控制 在TCP传输过程中，发送和接收速度受到缓存和网络情况的限制，如果发送过快，会造成数据丢失，降低信道利用率。流量控制就是将发送速率控制在合理范围内。 流量控制的实现 流量控制的实现主要通过改变窗口的大小。如图所示： 此例中，接收端每次应答的时候都会更新接收窗口值，该窗口值随着接收端的剩余缓存空间而改变。在第4次应答时，将窗口值设为了0，意味着接收窗口已满。此后又有了缓存空间，于是将窗口更新为2000。假设该更新分组丢失，则发送端无法得知接收端又有了缓存空间，发送端也无法得知分组丢失，那么就会陷入死锁。在这种情况下，TCP为每个连接设立了持续计时器，当接到窗口更新为0的分组时，启动计时器，一段时间之后，发送端会发送一个探测报文段，该报文段仅携带一个字节。接收端收到探测报文段后会更新窗口值。如果仍是0，则发送端再次启动持续计时器。 流量控制与传输效率 发送窗口中的数据不是简单连续发送的，而是要考虑信道上的传输效率。如果一则报文中的数据部分过短，会导致报头与数据部分比值过大，影响传输效率。所以有特定的机制来选择恰当的传输时机，保证较高的传输效率。第一种机制是由TCP维持一个最大报文长度MSS，当缓存中的数据达到MSS时就封装成一个TCP报文段发送出去；第二种机制是由发送方的应用进程指明发送报文段，即推送机制；第三种机制是使用计时器，每过一段时间就发送缓存中的已有数据。 在TCP协议中广泛使用的一种算法是Nagle算法。根据Nagle算法，若发送方将数据存入发送缓存，则先发送第一个字节，将后面到达的数据缓存起来。当接收方对第一个字节数据确认后，再将缓存中的所有数据封装为一个报文段发送，同时对后面到达的数据进行缓存。以后每收到一个确认就发送下一个报文段。Nagle还规定，当收到确认的数据占发送窗口的一半或全部时，立即发送下一个报文段，不需要等待确认。这样能进一步提高网络的吞吐量。 在Nagle的算法中可能会发生糊涂窗口问题。即假设接收方的缓存已满，此时接收方的应用进程只取走了很少的数据，接收窗口很小，此时向发送方发送了确认，发送方只能发送很少的数据到接收端，接收窗口又满了，陷入恶性循环，导致网络利用率很低。解决这个问题的方法是可以让接收方等待一定时间，使接收窗口有缓存的一半空闲空间或者足够容纳一个最长报文段MSS，就向发送方发送确认报文，开始正常的传输。此外，发送方发送的报文也不应该太小，应累积到MSS或者接收窗口的一半大小的数据再发送。]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>Network programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议中的滑窗协议（连续ARQ协议）]]></title>
    <url>%2F2019%2F03%2F28%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%BB%91%E7%AA%97%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP协议中的滑窗协议（连续ARQ协议）为什么需要滑动窗口协议（连续ARQ协议）TCP协议的滑窗协议的作用是提高信道利用率，同时在流量控制和拥塞管理中也会起到控制作用。根据TCP协议的停止等待协议，发送方在发送一个分组后需要等待接收方返回确认分组，在收到确认分组之后发送方才认为信息发送成功，否则根据超时重传机制重复发送。在这个过程中，如果发送方每发送一个分组就进入等待状态，则信道利用率会非常低，具体公式： U=\frac{T_{D}}{T_{D}+RTT+T_{A}}即发送分组时间与发送分组、平均往返时间和接受确认分组时间之和的比值。根据《计算机网络》的举例，假定1200km的传输距离，分组长度1200bit，传输速率1Mb/s， 则信道利用率约为5.66%，传输速率越高则利用率越低。因此，为了提高信道利用率，需要在发送分组和等待确认分组之间连续发送分组，而不是以空闲的状态等待。连续发送分组的数量受到发送方和接收方缓存空间和网络状态的影响，因此使用滑窗协议控制连续发送的字节数。 滑窗协议的工作方式基本过程滑动窗口的含义是：发送方维持一个可以连续发送的字节的序号，在序号范围内的字节可以连续发送，不需要等待确认分组；接收方维持一个已经接收到的字节的序号，对按顺序接收到的最高字节序号进行确认，并缓存未按序接收到的字节。因此，在滑窗协议的作用下，接收方不是对每个分组发送确认分组，而是采用累积确认的方式，对按序接受到的最后一个分组确认，表示此分组之前的所有分组都按序接收到了。这样做的好处是实现简单，缺点是不能反应已经接收到的分组的真实情况。如果发送方发送的分组中的第N个丢失，即使N之后分组被成功接收，也只能收到接收方对N-1和分组的确认，所以发送方需要重新发送从N开始的所有分组，即Go-back-N机制（回退N）。 具体过程对于发送方来说：发送窗口内的字节可以连续发送，不需要等待B的确认分组。同时已发送但未确认的数据都要保留，以备重新发送。发送窗口图示： 可以看见，在发送方窗口中，数据按照发送状态被分为四部分： 已发送且已收到确认 已发送但未收到确认 在发送窗口内但尚未发送 尚未进入发送窗口 对于接收方来说：对于接收窗口内的按序收到的最后一个字节发送确认分组给发送方，并且将按序收到的数据交付主机的进程，因此接收窗口中的数据主要包含非按序接收的字节和尚未交付主机进程的数据。接收窗口图示： 可以看见，在接收方窗口中，数据也可以按照接收状态分为四部分： 已收到并发送过确认分组且已交付主机进程 已收到但未交付主机或非按序字节 接收窗口中允许继续接收的部分 尚未进入接收窗口 根据图示可以看出发送窗口和接收窗口的变化过程，为了方便描述，设发送方为S(send),接收方为A(accept)。假设S发送窗口内的10个字节后，收到A对前5个字节的确认，此时发送窗口向前移动5个字节，相当于扩大了发送窗口中的可发送部分。此时如果第6个字节丢失或在网络中延迟，导致A没有收到它，而是先收到了第7个字节，则A无法对接下来收到的字节发送确认，因为A只能对按序收到的字节确认。S发送窗口中的数据继续发送，可发送区域不断缩小，直到发送窗口中都是已发送但未确认的字节，即发送窗口已满，且没有继续收到A的确认（缺失第6字节），则S必须停止发送。在超时重传机制的作用下，S经过一段时间后会重新发送从第6字节开始的数据，直到收到A的确认，然后继续滑动发送窗口，持续这个动态过程。在接收窗口中，如果检查出收到的分组有错误，则丢弃改分组。对于窗口的工作过程，还有一些要点： 发送窗口的大小是由接收方说明的，接收方会在TCP数据包的window字段，根据接收窗口的大小指明发送方可以设置的窗口大小。但是发送方的窗口大小不是每时每刻都保持与接收窗口一致。因为网络有延迟，接收方对窗口的调整信息可能不能及时传递到发送方，此外，发送窗口的大小还会根据网络的拥塞情况根据相应算法做调整。 TCP协议没有对已接收的无序字节的处理作出规定，通常是缓存在接收窗口中，等到缺失的字节到来后组成有序数据，再交付主机进程处理 TCP规定接收方必须有累积确认机制。接收端可以选择延迟确认，比如在需要发送数据时捎带上确认分组，但是推迟时间不能超过0.5秒。通常这种推迟确认的情况不会发生]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>Network Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reactor模式]]></title>
    <url>%2F2019%2F01%2F05%2FReactor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reactor模式实现I/O复用 Reactor模式简介 在网络服务器编程中，一个常见的实际场景是服务器需要与多个套接字连接，如果某个套接字可读，即读取该套接字数据并做相关处理。处理这样场景的最简单思路就是用非阻塞的read对所有套接字轮询，或者使用select和poll进行轮询。因为轮询需要持续查看内核中某个套接字是否就绪，如果连接了大量套接字则每次轮询时间会很长，不利于I/O密集型应用。epoll作为加强版的poll不会随着监听的套接字数量增长而大幅降低效率。epoll也是通常会使用的I/O复用模型，但是epoll作为linux系统调用过于底层，在实际使用中常常对其按照某种事件处理机制进一步封装。一种常用的事件处理机制工作方式如下描述： 服务器连接的套接字可以抽象为事件源，每个事件对应的处理函数可以抽象为事件处理器，在事件源和事件处理器之间需要一个事件分离器进行分配，将每个事件分配到对应的事件处理器中进行处理。事件分离器用epoll实现。应用程序事先在事件分离器中注册相应的事件处理器，当事件发生时，epoll将该事件分配到已注册的事件处理器中进行处理，由事件处理器完成实际的读写。这种事件处理机制就是Reactor模式。 Reactor的核心在于以事件为驱动，而不是主动调用处理函数等待事件发生。在Reactor模式中，应用程序需要先注册好处理事件的接口，当事件发生时回调已经注册好的处理函数进行处理。这种被动调用的方式有如下优点： 响应速度快； 可扩展性强，能够方便的增加Reactor实例个数来充分利用CPU资源； 可复用性强，Reactor与具体的业务逻辑无关，只与I/O调度有关，具有很高的复用性； 编程简单，避免了多线程/多进程的切换开销。 Reactor模式组成 如图中所示，Reactor为时间反应器， Event Handler为时间处理器，Event Demultiplexer为时间分离器， Concrete Event Handler封装时间处理器， Handle为时间源。 事件源（handler）：一般是描述符，由操作系统提供。可以使socket，文件描述符等。可以来自系统内部，也可以来自系统内部； 事件反应器（Reactor）：是Reactor模式的核心，负责应用程序控制事件的调度。包括应用程序的注册，删除事件处理器和相关描述符的接口。它使用事件分离器等待事件的发生，事件发生时，事件分离器会回调事先注册好的回调函数来处理对应事件； 事件分离器（Event Demultiplexer）：一般由epoll实现，调用者会被阻塞直到事件分离器上注册的事件发生； 事件处理器（Event Handler）：提供了一组能够处理对应事件的接口，这组接口事先由应用程序注册。 Reactor事件处理流程 首先是事件注册部分，应用程序将期待注册的套接字描述符作为事件源，将对应的回调函数和该描述符注册到事件处理器上，然后将该事件处理器注册到事件反应器上。事件反应器将注册信息再次注册到事件分离器epoll中，在epoll中通过epoll_ctl进行添加描述符及事件，并层层返回注册结果； 然后是事件处理部分，事件反应器通过epoll_wait等待注册事件发生。一旦事件真的发生，epoll_wait将会返回，并将包含该事件的事件集返回到事件反应器，反应器根据事件源找到该事件的处理器，并根据事件类型调用之前在事件处理器中注册的回调函数，在回调函数中完成事件的处理。 根据Reactor模式的具体流程可知，应用程序只参与了最初的注册步骤，具体的等待事件发生和事件处理都由Reactor分配。因此， 在Reactor模式中，应用程序无须关心事件的来源和发生时间，只要完成回调函数和描述符的注册即可，事件的处理流程被Reactor控制翻转了。这一特性对应了设计模式中的好莱坞原则。 Reactor的使用 在初始化阶段， 我们将服务器监听套接字及对应的处理函数注册到Reactor中，然后系统进入Reactor的大循环中等待事件的发生。 接下来，如果发生监听套接字可读事件，则表示有新连接产生。Reactor回调之前注册好的回调函数，即通过accept系统调用获取新连接的套接字，并将该连接的描述符和对应的处理函数注册到Reactor中。执行完监听套接字的处理函数后，若仍有事件未处理，则继续进入该事件对应的回调函数中进行处理；否则进入下一次事件循环中，继续调用epoll阻塞等待事件的发生； 这时，Reactor上已经注册了两类事件：监听套接字可读事件（代表新连接的产生）和连接套接字可读事件（代表有从客户端发来的数据）。 在接下来的循环中，如果到达的事件是监听套接字事件，则重复上面的步骤；若到达的是连接套接字事件，则Reactor会回调对应的连接套接字Handler。在这次调用中，先通过read系统调用读取收到的数据，然后进行具体的处理。处理结束后若还有事件待处理，则继续处理，否则进入下次循环，epoll阻塞等待事件的发生。 以上描述的是单线程中服务器使用Reactor模式建立新的客户端连接并接受、处理客户端数据的工作。Reactor满足了高并发和高性能的需求，同时实现了网络细节与业务逻辑的分离。在使用中只需要在不同事件对应的Handler中实现具体的业务逻辑即可。]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>C++服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转载）C++虚函数表解析]]></title>
    <url>%2F2018%2F10%2F25%2F%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[C++ 虚函数表解析 &nbsp; 陈皓 http://blog.csdn.net/haoel &nbsp; &nbsp; 前言 &nbsp; C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 &nbsp; &nbsp; 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 &nbsp; 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 &nbsp; 言归正传，让我们一起进入虚函数的世界。 &nbsp; &nbsp; 虚函数表 &nbsp; 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 &nbsp; 这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 &nbsp; 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 &nbsp; 假设我们有这样的一个类： &nbsp; class Base { &nbsp;&nbsp;&nbsp;&nbsp; public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base::h" &lt;&lt; endl; } &nbsp; }; &nbsp; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef void(*Fun)(void); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base b; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "虚函数表地址：" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "虚函数表 — 第一个函数地址：" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Invoke the first virtual function&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)*((int*)*(int*)(&amp;b)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; 实际运行经果如下：(Windows XP+VS2003,&nbsp; Linux 2.6.22 + GCC 4.1.3) &nbsp; 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f &nbsp; &nbsp; 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+0);&nbsp; // Base::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+1);&nbsp; // Base::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+2);&nbsp; // Base::h() &nbsp; 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： &lt;?xml:namespace prefix = v /&gt; 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 &nbsp; &nbsp; 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 &nbsp; 一般继承（无虚函数覆盖） &nbsp; 下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： &nbsp; &nbsp; 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示： &nbsp; 对于实例：Derive d; 的虚函数表如下： &nbsp; 我们可以看到下面几点： 1）虚函数按照其声明顺序放于表中。 2）父类的虚函数在子类的虚函数前面。 &nbsp; 我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 &nbsp; &nbsp; &nbsp; 一般继承（有虚函数覆盖） &nbsp; 覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 &nbsp; &nbsp; &nbsp; 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： &nbsp; &nbsp; 我们从表中可以看到下面几点， 1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 2）没有被覆盖的函数依旧。 &nbsp; 这样，我们就可以看到对于下面这样的程序， &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base *b = new Derive(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;f(); &nbsp; 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 &nbsp; &nbsp; &nbsp; 多重继承（无虚函数覆盖） &nbsp; 下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 &nbsp; &nbsp; &nbsp; 对于子类实例中的虚函数表，是下面这个样子： &nbsp; 我们可以看到： 1）&nbsp; 每个父类都有自己的虚表。 2）&nbsp; 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） &nbsp; 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 &nbsp; &nbsp; &nbsp; &nbsp; 多重继承（有虚函数覆盖） &nbsp; 下面我们再来看看，如果发生虚函数覆盖的情况。 &nbsp; 下图中，我们在子类中覆盖了父类的f()函数。 &nbsp; &nbsp; &nbsp; 下面是对于子类实例中的虚函数表的图： &nbsp; &nbsp; 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 *b1 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base2 *b2 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base3 *b3 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f(); //Derive::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;f(); //Derive::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;f(); //Derive::f() &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;g(); //Base1::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;g(); //Base2::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;g(); //Base3::g() &nbsp; &nbsp; 安全性 &nbsp; 每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 &nbsp; 一、通过父类型的指针访问子类自己的虚函数 我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 *b1 = new Derive(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f1();&nbsp; //编译出错 &nbsp; 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） &nbsp; &nbsp; 二、访问non-public的虚函数 另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 &nbsp; 如： &nbsp; class Base { &nbsp;&nbsp;&nbsp; private: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } &nbsp; }; &nbsp; class Derive : public Base{ &nbsp; }; &nbsp; typedef void(*Fun)(void); &nbsp; void main() { &nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp; Fun&nbsp; pFun = (Fun)*((int*)*(int*)(&amp;d)+0); &nbsp;&nbsp;&nbsp; pFun(); } &nbsp; &nbsp; 结束语 C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 &nbsp; 在文章束之前还是介绍一下自己吧。我从事软件研发有十个年头了，目前是软件开发技术主管，技术方面，主攻Unix/C/C++，比较喜欢网络上的技术，比如分布式计算，网格计算，P2P，Ajax等一切和互联网相关的东西。管理方面比较擅长于团队建设，技术趋势分析，项目管理。欢迎大家和我交流，我的MSN和Email是：haoel@hotmail.com&nbsp; &nbsp; 附录一：VC中查看虚函数表 &nbsp; 我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的） 附录 二：例程 下面是一个关于多重继承的虚函数表访问的例程： &nbsp; #include &lt;iostream&gt; using namespace std; &nbsp; class Base1 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base1::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base1::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base1::h" &lt;&lt; endl; } &nbsp; }; &nbsp; class Base2 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base2::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base2::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base2::h" &lt;&lt; endl; } }; &nbsp; class Base3 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base3::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base3::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base3::h" &lt;&lt; endl; } }; &nbsp; &nbsp; class Derive : public Base1, public Base2, public Base3 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Derive::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g1() { cout &lt;&lt; "Derive::g1" &lt;&lt; endl; } }; &nbsp; &nbsp; typedef void(*Fun)(void); &nbsp; int main() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int** pVtab = (int**)&amp;d; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base1's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Derive's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][4]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base2's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base3's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; } &nbsp; (转载时请注明作者和出处。未经许可，请勿用于商业用途) &nbsp; 更多文章请访问我的Blog: http://blog.csdn.net/haoel &nbsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++中的int, long, long long]]></title>
    <url>%2F2018%2F10%2F24%2FC-%E4%B8%AD%E7%9A%84int-long-long-long%2F</url>
    <content type="text"><![CDATA[C++中的int, long, long long C++中的三种整数数据类型，int， long， long long是平时极为常用的类型，在此总结一下它们的用法。 int， long，和long long之间可以隐式转换，规则为从取值范围小到取值范围大的转换，例如int&gt;long 三者占用的空间，根据《C++ primer》算数类型的尺寸根据不同的机器和编译器会有所差别。C++只规定了最小尺寸，允许编译器赋予更大的尺寸。 类型 最小尺寸 short 16位 int 16位 long 32位 long long 64位 C语言规定int至少和short一样大，long至少和int一样大， long long 至少和long一样大。其中long long是C11中新定义的。通常来讲，short是半个机器字长，int是一个机器字长， long是一到两个机器字长， long long在任何环境下都是8个字节。 一般情况下，32位系统中short为2个字节，int为4个字节，long与int相同为4个字节， long long为8个字节；64位系统中short依然为2个字节，为了向前兼容，int也会被编译为4个字节，long为8个字节，long long为8个字节。 所以在实际使用中，不同的编译器对算数类型的处理可能会有差别，在不同系统和编译器中得到的算数类型尺寸不一定相同，除了short是稳定的2个字节，以及long long是稳定的8个字节。所以在需要获取算数类型尺寸的时候最好用sizeof()， 而不是凭经验认定int就是4个字节或long就是8个字节, 实际上long与int尺寸相同的情况很常见。需要扩大尺寸的话尽量用long long，可以保证是8个字节。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列]]></title>
    <url>%2F2018%2F08%2F23%2FLeetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列 Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。 C++ 123456789101112class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, buy = INT_MAX; for(int price:prices) &#123; buy = min(buy, price); res = max(price - buy, res); &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 本题有两种思路。 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。 C++ 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, n = prices.size(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res += prices[i + 1] - prices[i]; &#125; &#125; return res; &#125;&#125;; 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。 C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, sell = 0; int prebuy = 0, presell = 0; for(int price : prices) &#123; prebuy = buy; presell = sell; buy = max(presell - price, prebuy); sell = max(prebuy + price, presell); &#125; int res = sell; return res; &#125;&#125;; Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 感觉这道题目解法不是很好理解，参考Grandyang的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用&quot;局部最优和全局最优&quot;的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit); global[i][j] = max(global[i-1][j], local[i][j]); 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit) 中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。 C++ 123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) &#123; return 0; &#125; int n = prices.size(); int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;; for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = 1; j &lt;= 2; ++j) &#123; l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff); //由局部的极值推导全局最值 g[i][j] = max(g[i-1][j], l[i][j]); &#125; &#125; return g[n-1][2]; &#125;&#125;; 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自Grandyang C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if (prices.empty()) return 0; int g[3] = &#123;0&#125;; int l[3] = &#123;0&#125;; for (int i = 0; i &lt; prices.size() - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; for (int j = 2; j &gt;= 1; --j) &#123; l[j] = max(g[j - 1] + diff, l[j] + diff); g[j] = max(l[j], g[j]); &#125; &#125; return g[2]; &#125;&#125;; 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。 Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。 C++ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 1||prices.empty() ||k == 0) &#123; return 0; &#125; if(k &gt;= prices.size()) &#123; return maxProfit_1(prices); &#125; int n = prices.size(); vector&lt;int&gt; g(k+1, 0); vector&lt;int&gt; l(k+1, 0); for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = k; j &gt;=1; --j) &#123; l[j] = max(g[j-1]+diff, l[j]+diff); g[j] = max(g[j], l[j]); &#125; &#125; return g[k]; &#125; int maxProfit_1(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int n = prices.size(); for(int i = 1; i &lt; n; ++i) &#123; if(prices[i] &gt;prices[i-1]) &#123; res += (prices[i] - prices[i-1]); &#125; &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考Grandyang的方法，维护三个数组buy[],sell[]和rest[]。 其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为： buy[i] = max(rest[i-1]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); rest[i] = max(buy[i-1], sell[i-1], rest[i-1]); 上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以 rest[i] = max(sell[i-1], rest[i-1]); 此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为 buy[i] = max(sell[i-2]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); 可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。 C++ 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0; for (int price : prices) &#123; pre_buy = buy; buy = max(pre_sell - price, pre_buy); pre_sell = sell; sell = max(pre_buy + price, pre_sell); &#125; return sell; &#125;&#125;; 以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。Grandyang的博客给我提供了很大帮助。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
</search>
