<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++中的int, long, long long</title>
      <link href="/2018/10/24/C-%E4%B8%AD%E7%9A%84int-long-long-long/"/>
      <url>/2018/10/24/C-%E4%B8%AD%E7%9A%84int-long-long-long/</url>
      <content type="html"><![CDATA[<h1 id="C-中的int-long-long-long"><a href="#C-中的int-long-long-long" class="headerlink" title="C++中的int, long, long long"></a>C++中的int, long, long long</h1><p>C++中的三种整数数据类型，int， long， long long是平时极为常用的类型，在此总结一下它们的用法。</p><p> int， long，和long long之间可以隐式转换，规则为从取值范围小到取值范围大的转换，例如int&gt;long</p><p> 三者占用的空间，根据《C++ primer》算数类型的尺寸根据不同的机器和编译器会有所差别。C++只规定了最小尺寸，允许编译器赋予更大的尺寸。</p><table><thead><tr><th>类型</th><th>最小尺寸</th></tr></thead><tbody><tr><td>short</td><td>16位</td></tr><tr><td>int</td><td>16位</td></tr><tr><td>long</td><td>32位</td></tr><tr><td>long long</td><td>64位</td></tr></tbody></table><p>C++语言规定int至少和short一样大，long至少和int一样大， long long 至少和long一样大。其中long long是C++11中新定义的。通常来讲，short是半个机器字长，int是一个机器字长， long是一到两个机器字长， long long在任何环境下都是8个字节。</p><p>一般情况下，32位系统中short为2个字节，int为4个字节，long与int相同为4个字节， long long为8个字节；64位系统中short依然为2个字节，为了向前兼容，int也会被编译为4个字节，long为8个字节，long long为8个字节。</p><p>所以在实际使用中，不同的编译器对算数类型的处理可能会有差别，在不同系统和编译器中得到的算数类型尺寸不一定相同，除了short是稳定的2个字节，以及long long是稳定的8个字节。所以在需要获取算数类型尺寸的时候最好用sizeof()， 而不是凭经验认定int就是4个字节或long就是8个字节, 实际上long与int尺寸相同的情况很常见。需要扩大尺寸的话尽量用long long，可以保证是8个字节。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列</title>
      <link href="/2018/08/23/Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97/"/>
      <url>/2018/08/23/Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock系列"><a href="#Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock系列" class="headerlink" title="Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列"></a>Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列</h1><ol><li><h2 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p> Note that you cannot sell a stock before you buy one.</p><p> Example 1:</p><p> Input: [7,1,5,3,6,4]<br> Output: 5<br> Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</p><pre><code>Not 7-1 = 6, as selling price needs to be larger than buying price.</code></pre><p> Example 2:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0, buy = INT_MAX;</span><br><span class="line">    for(int price:prices)</span><br><span class="line">    &#123;</span><br><span class="line">        buy = min(buy, price);</span><br><span class="line">        res = max(price - buy, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a>Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p><p> Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [7,1,5,3,6,4]<br> Output: 7<br> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</p><pre><code>Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</code></pre><p> Example 2:</p><p> Input: [1,2,3,4,5]<br> Output: 4<br> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</p><pre><code>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you areengaging multiple transactions at the same time. You must sell before buying again.</code></pre><p> Example 3:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 本题有两种思路。</p><p> 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res = 0, n = prices.size();</span><br><span class="line">        for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">            if (prices[i] &lt; prices[i + 1]) &#123;</span><br><span class="line">                res += prices[i + 1] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int buy = INT_MIN, sell = 0;</span><br><span class="line">        int prebuy = 0, presell = 0;</span><br><span class="line">        for(int price : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            prebuy = buy;</span><br><span class="line">            presell = sell;</span><br><span class="line">            buy = max(presell - price, prebuy);</span><br><span class="line">            sell = max(prebuy + price, presell);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = sell;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p> Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [3,3,5,0,0,3,1,4]<br> Output: 6<br> Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</p><pre><code>Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</code></pre><p> Example 2:</p><p> Input: [1,2,3,4,5]<br> Output: 4<br> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</p><pre><code>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you areengaging multiple transactions at the same time. You must sell before buying again.</code></pre><p> Example 3:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 感觉这道题目解法不是很好理解，参考<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a>的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用”局部最优和全局最优”的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为</p><p> local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit);</p><p> global[i][j] = max(global[i-1][j], local[i][j]);</p><p> 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在</p><p> local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit)</p><p>  中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。</p><p> 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.size(); </span><br><span class="line">        int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int diff = prices[i] - prices[i-1];</span><br><span class="line">            for(int j = 1; j &lt;= 2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff);    //由局部的极值推导全局最值</span><br><span class="line">                g[i][j] = max(g[i-1][j], l[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[n-1][2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a></p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">        if (prices.empty()) return 0;</span><br><span class="line">        int g[3] = &#123;0&#125;;</span><br><span class="line">        int l[3] = &#123;0&#125;;</span><br><span class="line">        for (int i = 0; i &lt; prices.size() - 1; ++i) &#123;</span><br><span class="line">            int diff = prices[i + 1] - prices[i];</span><br><span class="line">            for (int j = 2; j &gt;= 1; --j) &#123;</span><br><span class="line">                l[j] = max(g[j - 1] + diff, l[j] + diff);</span><br><span class="line">                g[j] = max(l[j], g[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。</p></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a>Best Time to Buy and Sell Stock IV</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete at most k transactions.</p><p> Note:<br> You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [2,4,1], k = 2<br> Output: 2<br> Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</p><p> Example 2:</p><p> Input: [3,2,6,5,0,3], k = 2<br> Output: 7<br> Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</p><pre><code>Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</code></pre></li></ol><pre><code>这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。C++<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size() == 1||prices.empty() ||k == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &gt;= prices.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return maxProfit_1(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        vector&lt;int&gt; g(k+1, 0);</span><br><span class="line">        vector&lt;int&gt; l(k+1, 0);</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int diff = prices[i] - prices[i-1];</span><br><span class="line">            for(int j = k; j &gt;=1; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                l[j] = max(g[j-1]+diff, l[j]+diff);</span><br><span class="line">                g[j] = max(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxProfit_1(vector&lt;int&gt;&amp; prices)</span><br><span class="line">    &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i] &gt;prices[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                res += (prices[i] - prices[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ol start="5"><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a>Best Time to Buy and Sell Stock with Cooldown</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><pre><code>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</code></pre><p> Example:</p><p> Input: [1,2,3,0,2]<br> Output: 3<br> Explanation: transactions = [buy, sell, cooldown, buy, sell]</p><p> 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a>的方法，维护三个数组buy[],sell[]和rest[]。</p></li></ol><pre><code>其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为：buy[i] = max(rest[i-1]-price, buy[i-1]);sell[i] = max(buy[i-1]+price, sell[i-1]);rest[i] = max(buy[i-1], sell[i-1], rest[i-1]);上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以rest[i] = max(sell[i-1], rest[i-1]);此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为buy[i] = max(sell[i-2]-price, buy[i-1]);sell[i] = max(buy[i-1]+price, sell[i-1]);可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。C++<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            pre_buy = buy;</span><br><span class="line">            buy = max(pre_sell - price, pre_buy);</span><br><span class="line">            pre_sell = sell;</span><br><span class="line">            sell = max(pre_buy + price, pre_sell);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。[Grandyang](http://www.cnblogs.com/grandyang/p/4281975.html)的博客给我提供了很大帮助。</code></pre>]]></content>
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
