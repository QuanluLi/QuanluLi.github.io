<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列]]></title>
    <url>%2F2018%2F08%2F23%2FLeetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列 Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。 C++ 123456789101112class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, buy = INT_MAX; for(int price:prices) &#123; buy = min(buy, price); res = max(price - buy, res); &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 本题有两种思路。 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。 C++ 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, n = prices.size(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res += prices[i + 1] - prices[i]; &#125; &#125; return res; &#125;&#125;; 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。 C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, sell = 0; int prebuy = 0, presell = 0; for(int price : prices) &#123; prebuy = buy; presell = sell; buy = max(presell - price, prebuy); sell = max(prebuy + price, presell); &#125; int res = sell; return res; &#125;&#125;; Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 感觉这道题目解法不是很好理解，参考Grandyang的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用”局部最优和全局最优”的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit); global[i][j] = max(global[i-1][j], local[i][j]); 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit) 中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。 C++ 123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) &#123; return 0; &#125; int n = prices.size(); int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;; for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = 1; j &lt;= 2; ++j) &#123; l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff); //由局部的极值推导全局最值 g[i][j] = max(g[i-1][j], l[i][j]); &#125; &#125; return g[n-1][2]; &#125;&#125;; 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自Grandyang C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if (prices.empty()) return 0; int g[3] = &#123;0&#125;; int l[3] = &#123;0&#125;; for (int i = 0; i &lt; prices.size() - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; for (int j = 2; j &gt;= 1; --j) &#123; l[j] = max(g[j - 1] + diff, l[j] + diff); g[j] = max(l[j], g[j]); &#125; &#125; return g[2]; &#125;&#125;; 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。 Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。 C++ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 1||prices.empty() ||k == 0) &#123; return 0; &#125; if(k &gt;= prices.size()) &#123; return maxProfit_1(prices); &#125; int n = prices.size(); vector&lt;int&gt; g(k+1, 0); vector&lt;int&gt; l(k+1, 0); for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = k; j &gt;=1; --j) &#123; l[j] = max(g[j-1]+diff, l[j]+diff); g[j] = max(g[j], l[j]); &#125; &#125; return g[k]; &#125; int maxProfit_1(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int n = prices.size(); for(int i = 1; i &lt; n; ++i) &#123; if(prices[i] &gt;prices[i-1]) &#123; res += (prices[i] - prices[i-1]); &#125; &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock with CooldownSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考Grandyang的方法，维护三个数组buy[],sell[]和rest[]。 其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为： buy[i] = max(rest[i-1]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); rest[i] = max(buy[i-1], sell[i-1], rest[i-1]); 上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以 rest[i] = max(sell[i-1], rest[i-1]); 此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为 buy[i] = max(sell[i-2]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); 可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。 C++ 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0; for (int price : prices) &#123; pre_buy = buy; buy = max(pre_sell - price, pre_buy); pre_sell = sell; sell = max(pre_buy + price, pre_sell); &#125; return sell; &#125;&#125;; 以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。[Grandyang](http://www.cnblogs.com/grandyang/p/4281975.html)的博客给我提供了很大帮助。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
</search>
