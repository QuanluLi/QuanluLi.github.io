<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++中的虚函数</title>
      <link href="/2019/04/06/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/06/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="C-中的虚函数"><a href="#C-中的虚函数" class="headerlink" title="C++中的虚函数"></a>C++中的虚函数</h1><h2 id="为什么需要虚函数"><a href="#为什么需要虚函数" class="headerlink" title="为什么需要虚函数"></a>为什么需要虚函数</h2><p>虚函数是用来实现C++的多态特性的。多态性主要体现在用相同的代码来表达不同的算法或函数，具体在虚函数机制中的实现，是通过由派生类重新定义并覆盖基类中的虚函数，来实现与基类不同的函数功能，并且不同的派生类之间相同虚函数的功能也可以不同，也就是多态、多种形态。由此机制产生的基类指针可以指向派生类的对象，调用与本身静态类型不同的对象的函数，从指针的角度来说，实现了相同的基类指针可以有多种形态。陈皓在博客中介绍这属于泛型技术，与模板技术，RTTI技术有相似的特点。</p><h2 id="虚函数的用法"><a href="#虚函数的用法" class="headerlink" title="虚函数的用法"></a>虚函数的用法</h2><p>虚函数的示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base() = <span class="keyword">default</span>;</span><br><span class="line">Base(<span class="built_in">string</span> input) :name_b(input)&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;                <span class="comment">//通常含有虚函数的基类都应该定义一个虚析构函数。因为虚函数是在运行期间动态绑定的，基类指针可能指向派生类的对象，这样就可能引发析构函数不对应的问题，即需要析构派生类对象时调用了基类的析构函数。所以需要定义一个虚析构函数，虚析构函数与虚函数一样都是动态绑定的，因此在delete时能够保证调用正确的析构函数。虚析构函数不符合“三五法则”，即使需要定义虚析构函数，但是不需要定义拷贝构造函数和拷贝赋值函数，它是一个特例，由动态绑定机制产生的特例。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This is foo_1 in Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This is foo_2 in Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> name_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived() = <span class="keyword">default</span>;</span><br><span class="line">Derived(<span class="built_in">string</span> input):name_d(input)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_1</span><span class="params">()</span> final </span>&#123;                            <span class="comment">//final表示不允许这个虚函数在派生类中再被覆盖</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This is foo_1 in derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_2</span><span class="params">()</span> override</span>;   <span class="comment">//override表示覆盖基类版本,用override的好处在于可以避免发生函数名称或参数数量的错误。如果没有override，假如在派生类中定义的函数与基类中有相同名称但是类型或参数不同，会被编译器认为是函数的重载，而不会覆盖基类中的同名虚函数，但这种情况通常是程序员本意想要覆盖虚函数但犯了错误，这种错误很难查出。如果使用override关键字，则编译器会发现派生类中要进行覆盖的函数与基类中的虚函数不同，因此不会执行覆盖的操作，而是会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> name_d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++多态性实现的关键，是基类指针指向的对象可能与自身的静态类型不符，派生类对象的指针和引用可以向基类的指针和引用进行类型转换。但是需要注意的是，对象本身之间不存在类型转换，该操作仅限于指针和引用。</p><h2 id="虚函数的动态绑定"><a href="#虚函数的动态绑定" class="headerlink" title="虚函数的动态绑定"></a>虚函数的动态绑定</h2><p>当我们使用含有虚函数的基类时，需要对所有的虚函数进行定义。因为虚函数是在运行期间才确定调用哪个版本，在访问到相应的内存后才知道是调用这个虚函数，所以编译器在编译时并不知道具体使用的是哪个虚函数，所以必须对所有虚函数进行定义，防止访问到未定义的函数，即使不会用到的虚函数也要有定义。虚函数有传递性，基类中定义的虚函数在派生类中被覆盖后依然是虚函数，仍然可以被派生类的派生类继续覆盖。除非使用final关键字禁止该虚函数被覆盖。</p><h2 id="回避虚函数机制"><a href="#回避虚函数机制" class="headerlink" title="回避虚函数机制"></a>回避虚函数机制</h2><p>有时我们需要使用指向派生类的基类指针调用基类的虚函数而不是派生类的虚函数，这时就需要回避虚函数机制。做法很简单，使用作用域运算符就可以实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *b;</span><br><span class="line">b = <span class="keyword">new</span> Drive();</span><br><span class="line">b-&gt;foo_1(); <span class="comment">//调用的是派生类的虚函数</span></span><br><span class="line">b-&gt;Base::foo_1(); <span class="comment">//调用的是基类的虚函数</span></span><br></pre></td></tr></table></figure><p>C++primer中提到，在使用回避虚函数机制时要注意一点：如果派生类中的虚函数需要调用它的基类版本，但是在编程时忘记使用作用域运算符，就会导致该派生类虚函数无限调用自身，陷入死循环。所以在使用虚函数回避机制时，要十分明确调用哪个版本的虚函数。</p><h2 id="纯虚函数与抽象基类"><a href="#纯虚函数与抽象基类" class="headerlink" title="纯虚函数与抽象基类"></a>纯虚函数与抽象基类</h2><p>纯虚函数的作用在于声明一个具有一般性的、没有具体含义的函数，通常用来表示一个通用的、抽象的概念，这个函数的只能由它的派生类覆盖来赋予具体的算法和含义。含有未被覆盖的纯虚函数的基类叫做抽象基类，抽象基类不能实例化一个对象，因为纯虚函数没有定义也没有具体含义。</p><p>使用纯虚函数时只要在声明时加上<code>=0</code>即可；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Abstract() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Abstract() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pure_v</span> <span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚函数也可以拥有定义，但是不能在类的内部定义，只能写在外部；不能创建抽象基类的对象，即使纯虚函数有类外定义也不行。</p><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>关于虚函数表的内容，我觉得陈皓的博客讲的非常好，<a href="https://coolshell.cn/articles/12165.html" title="虚函数表解析" target="_blank" rel="noopener">C++虚函数表解析</a>。这篇博客中关于类对象的首地址描述似乎有些问题，根据实验，类对象的首地址确实是虚函数表的地址，但是对象的首地址与第一个虚函数的地址并不一致，实际上虚函数表并不存储在类对象的数据区域中，而是在对象的数据区存储指向虚函数表的虚表指针，因此类对象的首地址与第一个虚函数的首地址并不相同，这里容易出现误解。关于C++对象的存储模型可以参考博客<a href="https://www.cnblogs.com/alone-striver/p/7875741.html" title="C++类的存储方式及虚函数表" target="_blank" rel="noopener">C++类的存储方式及虚函数表</a>。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议中链接的建立与断开</title>
      <link href="/2019/03/29/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/"/>
      <url>/2019/03/29/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/</url>
      <content type="html"><![CDATA[<h1 id="TCP协议中链接的建立与断开"><a href="#TCP协议中链接的建立与断开" class="headerlink" title="TCP协议中链接的建立与断开"></a>TCP协议中链接的建立与断开</h1><p>根据TCP协议，运输连接有三个阶段：连接的建立，数据传输和连接的释放。其中数据的传输部分主要又停止等待协议，流量控制和拥塞控制等主要内容，保证数据的可靠到达和网络的性能。连接的建立和释放同样有完整的过程，确保连接建立和释放的正确。</p><h2 id="TCP协议中链接的建立"><a href="#TCP协议中链接的建立" class="headerlink" title="TCP协议中链接的建立"></a>TCP协议中链接的建立</h2><p>TCP采用的是client和server的模型，发起连接的一方是client，接受连接的一方是server。连接的成功建立要经历三次握手。三次握手的主要目的就是初始化报文序号seq，并通知对方自己的初始sequence number。</p><p><img src="/img/连接和释放/三次握手与四次挥手.jpg" alt="三次握手与四次挥手" title="三次握手与四次挥手"></p><ul><li>第一次握手：在建立连接之前，server端需要先创建传输控制块TCB，是服务器的进程进入listen状态，准备好接受client发来的连接请求；client同样创建TCB，然后向server发送连接请求报文段，SYN报文段。SYN报文段中，SYN标志位被设为1，并选择一个 初始序号seq=x。SYN报文段不能携带数据但是要占用一个序号。发送SYN报文段之后，client进入SYN-SENT（同步已发送）状态</li><li>第二次握手：server端接收到连接请求后，如果同意建立连接，就发送一个确认报文。在确认报文段中，ACK和SYN都置为1，确认号是初始序号加1，即x+1，确认报文的序号是server自己选择的初始序号。确认报文段也占一个序号并且不能携带数据。发送确认报文段后，server进入SYN-RCVD（同步收到）状态</li><li>第三次握手：client在收到server的确认报文之后，还要对该确认报文进行确认，client向server发送一个确认报文，该报文中ACK标识位置为1，序号是x+1，确认序号是y+1。该确认报文可以携带数据，也可以不携带。如果不携带数据就不消耗序号。client发送出确认报文之后连接已经建立，client进入ESTABLISHED状态；server收到client的确认报文之后，也进入ESTABLISHED状态，连接建立</li></ul><h3 id="第三次握手的原因"><a href="#第三次握手的原因" class="headerlink" title="第三次握手的原因"></a>第三次握手的原因</h3><p>client对server的确认报文进行确认的主要原因是<strong>防止已经失效的连接请求意外地到达server端</strong>。已失效的连接请求的产生原因可能是，client先发送了一个连接请求，但是在网络中某处延迟了，然后client重新发送连接请求，第二次的连接请求成功与server建立连接，然后在该连接断开后，第一个连接请求到达了server，导致server误认为client又发送了一次连接请求。如果没有第三次握手的机制，server就会单方面建立连接，等待client发来数据，导致资源浪费。因此，第三次握手是有必要的。</p><h2 id="TCP协议中连接的释放"><a href="#TCP协议中连接的释放" class="headerlink" title="TCP协议中连接的释放"></a>TCP协议中连接的释放</h2><p>断开连接过程中的四次挥手实际上是两次，因为TCP连接是全双工的，断开过程中client和server都需要发送FIN以及接收对方对FIN的确认，所以client发送FIN，server接收并确认，server发送FIN，client接收并确认，是一个对称的过程。client和server都可以主动断开连接。</p><p>假设client主动断开连接：</p><ul><li>第一次挥手： 此时client处于ESTABLISHED状态，client发送终止连接的报文，将FIN置为1，设序号seq=u。此时client进入FIN-WAIT-1状态。FIN报文段不携带数据但是要消耗一个序号</li><li>第二次挥手： server收到client发来的FIN报文段后发送确认报文，将ACK置为1，确认号ack=u+1，随后进入CLOSE-WAIT状态。client在收到ACK后进入FIN-WAIT-2状态。此时TCP连接处于半关闭状态，如果server有数据要发送的话，client还是会接收，但是client不会再向server发送数据了</li><li>第三次挥手： server如果没有要发送的数据，就向client发送FIN报文段，将FIN置为1，ACK置为1，并重复上一次发送过的确认号ack=u+1。发送后，server进入LAST-ACK状态</li><li>第四次挥手： client在收到server的FIN报文段后，需要进行确认，发送确认报文段，将ACK置为1，确认号是收到的FIN序号加1.发送后进入TIME-WAIT阶段。server在收到确认后进入CLOSE状态。client的TIME-WAIT状态会持续2MSL（最长报文段寿命），由时间等待计时器计时。</li></ul><h3 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME-WAIT状态的作用"></a>TIME-WAIT状态的作用</h3><ul><li>保证自己的确认报文段能被对方成功接收。假如没有TIME-WAIT，而是直接断开连接，那么如果确认报文在网络中丢失或延迟，导致对方没有收到，对方会重新发送FIN报文，此时连接已断开，无法收到对方重发的FIN报文段，对方就无法按步骤进入CLOSED状态</li><li>防止前面提到的已失效连接请求出现在本次连接中。这与连接建立的第三次握手起的作用一样，相当于双重保障。因为经过2MSL后，主动断开连接的一方发送的所有报文完全在网络中消失，确保之前发的连接请求也消失。</li></ul><p>因为被动方在收到ACK报文后立即进入CLOSED状态，因此被动方比主动方早进入CLOSED状态。</p><h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p>TCP连接会维护一个保活计时器，防止对方因为突发情况，没有按照正常的断开流程断开连接。通常server会在每次收到client的报文后重置保活计时器，一般等待时间是2小时。如果2小时内没有收到client的报文，则发送一个探测报文段，此后每隔75分钟发送一次，如果连续10个探测报文段都没有收到回应，则断开连接。</p>]]></content>
      
      <categories>
          
          <category> C++服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议中的拥塞控制</title>
      <link href="/2019/03/29/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/29/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="TCP协议中的拥塞控制"><a href="#TCP协议中的拥塞控制" class="headerlink" title="TCP协议中的拥塞控制"></a>TCP协议中的拥塞控制</h1><h2 id="为什么要进行拥塞控制"><a href="#为什么要进行拥塞控制" class="headerlink" title="为什么要进行拥塞控制"></a>为什么要进行拥塞控制</h2><p>在网络中，如果各个主机请求的资源超过了网络能够承载的负荷，则发生拥塞，网络的性能会变坏。发生拥塞的原因有很多，并不能通过简单地增加节点内存或提高处理速率来解决问题，而是一个平衡的问题。在网络中一定有某些节点的缓存和处理速率与其他节点不匹配，当某个节点的缓存较小时，会丢弃一些新到的分组，而相应的主机会重传这些分组，甚至会重传多次，这样导致网络中的拥塞更加严重。因此解决拥塞问题通常采用的手段是改变网络的可用资源，或降低源头发送的数据量。拥塞控制的难处在于整个计算机网络是一个动态问题，需要监控拥塞发生的位置和数据源头，这本身就需要一定的开销（在节点之间交换信息和命令，用于选择合适的拥塞控制策略）。随着网络的复杂化和高速化，很容易出现节点缓存不足的情况，从而造成拥塞，并且有时候拥塞控制策略本身也会成为导致拥塞的原因。</p><p>目前解决拥塞问题的思想主要借鉴控制论的原理，分为开环控制和闭环控制。开环控制就是在设计网络时尽量全面的考虑可能出现的拥塞问题，在系统运行起来之后不再进行额外的干预；闭环控制则是在网络工作过程中，根据网络内部流量分布信息实时作出调整，通常有以下几种措施：</p><ul><li>监测网络以便定位拥塞发生的位置和时间</li><li>将拥塞的信息发送到可以采取行动解决问题的地方（通常是信息的源头）</li><li>调整网络的运行以解决拥塞问题</li></ul><h2 id="几种具体的拥塞控制算法"><a href="#几种具体的拥塞控制算法" class="headerlink" title="几种具体的拥塞控制算法"></a>几种具体的拥塞控制算法</h2><p>1999年因特网建议标准RFC2581定义了四种拥塞控制的算法：慢开始(slow start)，拥塞避免(congestion avoidance)，快重传(fast retransmit)，快恢复(fast recovery)。</p><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>核心思想是从较小的发送窗口开始，比如初始发送窗口设为一个MSS，随后从小到大增长到拥塞窗口的值。例如，先设发送窗口为一个MSS，在收到确认后增加为2个MSS，此后每收到一个确认分组就增加一个MSS。由于发送窗口内的数据连续发送，所以发送完一个窗口内的数据后，发送窗口的值会翻一倍，亦即拥塞窗口cwnd翻一倍。每经过一个传输轮次（发送完发送窗口内的所有数据并受到确认，为一个传输轮次），cwnd就翻一倍。这样cwnd相当于随着传输轮次成指数增长，因此慢开始并不是指增长速度慢，而是开始时发送窗口较小导致发送速率慢，其实cwnd的增长速率反而很快。</p><p>拥塞窗口cwnd不能无限增长，否则会引起拥塞。因此，需要设置阈值ssthresh，即慢开始门限，慢开始门限将cwnd划分出三个状态：</p><ul><li>cwnd &lt; ssthresh时，使用慢开始算法</li><li>cwnd &gt; ssthresh时，使用拥塞避免算法</li><li>cwnd = ssthresh时，以上两种算法二选一</li></ul><p>其中拥塞避免算法是一种减缓cwnd增长的算法。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>核心思想是让cwnd不随传输轮次的增加成指数增长，而是成线性增长。每经过一个传输轮次就将cwnd增加一个MSS。通常拥塞避免算法和慢开始配合使用。</p><p><img src="/img/拥塞控制/cwnd.jpg" alt="cwnd" title="慢开始和拥塞避免"></p><p>如上图所示，不论在慢开始阶段还是拥塞避免阶段，只要网络中出现了拥塞现象，就将ssthresh减为原来的一半，然后将cwnd置为1，重新开始慢开始算法。这个过程也被称为“乘法减小”，即按1/2的比例缩小ssthresh。拥塞避免阶段也被称为“加法增大”，指cwnd的线性增长过程。</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传的核心思想是要求接收端在收到失序的报文段后立刻发送对最新按序报文段的确认，不能推迟捎带确认。跟非快重传方式相比（可以对失序报文什么也不做），快重传能够及时让发送端意识到报文的丢失，不必等到计时器到时再重传相应报文。快重传算法规定，如果发送端连续收到三个重复的确认，就认为有报文丢失（被确认的下一个报文），然后重新发送。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>快恢复通常配合快重传一起使用。步骤如下：</p><ul><li>发送端连续收到三个重复的确认后，执行“乘法减小”操作，将ssthresh减半。（丢失报文可能意味着网络状况变差）</li><li>ssthresh减半后不降cwnd置为1个MSS，而是置为ssthresh，然后执行拥塞避免算法。因为三个连续的重复确认能够到达发送端，意味着可能没有阻塞。</li></ul><p><img src="/img/拥塞控制/快恢复.jpg" alt="快恢复" title="快恢复"></p>]]></content>
      
      <categories>
          
          <category> C++服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Newwork progamming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议的流量控控制</title>
      <link href="/2019/03/28/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/28/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="TCP协议的流量控控制"><a href="#TCP协议的流量控控制" class="headerlink" title="TCP协议的流量控控制"></a>TCP协议的流量控控制</h1><h2 id="为什么需要流量控制"><a href="#为什么需要流量控制" class="headerlink" title="为什么需要流量控制"></a>为什么需要流量控制</h2><p>在TCP传输过程中，发送和接收速度受到缓存和网络情况的限制，如果发送过快，会造成数据丢失，降低信道利用率。流量控制就是将发送速率控制在合理范围内。</p><h2 id="流量控制的实现"><a href="#流量控制的实现" class="headerlink" title="流量控制的实现"></a>流量控制的实现</h2><p>流量控制的实现主要通过改变窗口的大小。如图所示：</p><p><img src="/img/流量控制/流量控制.png" alt="利用可变窗口进行流量控制" title="利用可变窗口进行流量控制"></p><p>此例中，接收端每次应答的时候都会更新接收窗口值，该窗口值随着接收端的剩余缓存空间而改变。在第4次应答时，将窗口值设为了0，意味着接收窗口已满。此后又有了缓存空间，于是将窗口更新为2000。假设该更新分组丢失，则发送端无法得知接收端又有了缓存空间，发送端也无法得知分组丢失，那么就会陷入死锁。在这种情况下，TCP为每个连接设立了持续计时器，当接到窗口更新为0的分组时，启动计时器，一段时间之后，发送端会发送一个探测报文段，该报文段仅携带一个字节。接收端收到探测报文段后会更新窗口值。如果仍是0，则发送端再次启动持续计时器。</p><h2 id="流量控制与传输效率"><a href="#流量控制与传输效率" class="headerlink" title="流量控制与传输效率"></a>流量控制与传输效率</h2><p>发送窗口中的数据不是简单连续发送的，而是要考虑信道上的传输效率。如果一则报文中的数据部分过短，会导致报头与数据部分比值过大，影响传输效率。所以有特定的机制来选择恰当的传输时机，保证较高的传输效率。第一种机制是由TCP维持一个最大报文长度MSS，当缓存中的数据达到MSS时就封装成一个TCP报文段发送出去；第二种机制是由发送方的应用进程指明发送报文段，即推送机制；第三种机制是使用计时器，每过一段时间就发送缓存中的已有数据。</p><p>在TCP协议中广泛使用的一种算法是Nagle算法。根据Nagle算法，若发送方将数据存入发送缓存，则先发送第一个字节，将后面到达的数据缓存起来。当接收方对第一个字节数据确认后，再将缓存中的所有数据封装为一个报文段发送，同时对后面到达的数据进行缓存。以后每收到一个确认就发送下一个报文段。Nagle还规定，当收到确认的数据占发送窗口的一半或全部时，立即发送下一个报文段，不需要等待确认。这样能进一步提高网络的吞吐量。</p><p>在Nagle的算法中可能会发生糊涂窗口问题。即假设接收方的缓存已满，此时接收方的应用进程只取走了很少的数据，接收窗口很小，此时向发送方发送了确认，发送方只能发送很少的数据到接收端，接收窗口又满了，陷入恶性循环，导致网络利用率很低。解决这个问题的方法是可以让接收方等待一定时间，使接收窗口有缓存的一半空闲空间或者足够容纳一个最长报文段MSS，就向发送方发送确认报文，开始正常的传输。此外，发送方发送的报文也不应该太小，应累积到MSS或者接收窗口的一半大小的数据再发送。</p>]]></content>
      
      <categories>
          
          <category> C++服务器设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议中的滑窗协议（连续ARQ协议）</title>
      <link href="/2019/03/28/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%BB%91%E7%AA%97%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/03/28/TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%BB%91%E7%AA%97%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="TCP协议中的滑窗协议（连续ARQ协议）"><a href="#TCP协议中的滑窗协议（连续ARQ协议）" class="headerlink" title="TCP协议中的滑窗协议（连续ARQ协议）"></a>TCP协议中的滑窗协议（连续ARQ协议）</h1><h2 id="为什么需要滑动窗口协议（连续ARQ协议）"><a href="#为什么需要滑动窗口协议（连续ARQ协议）" class="headerlink" title="为什么需要滑动窗口协议（连续ARQ协议）"></a>为什么需要滑动窗口协议（连续ARQ协议）</h2><p>TCP协议的滑窗协议的作用是提高信道利用率，同时在流量控制和拥塞管理中也会起到控制作用。根据TCP协议的停止等待协议，发送方在发送一个分组后需要等待接收方返回确认分组，在收到确认分组之后发送方才认为信息发送成功，否则根据超时重传机制重复发送。在这个过程中，如果发送方每发送一个分组就进入等待状态，则信道利用率会非常低，具体公式：</p><script type="math/tex; mode=display">U=\frac{T_{D}}{T_{D}+RTT+T_{A}}</script><p>即发送分组时间与发送分组、平均往返时间和接受确认分组时间之和的比值。根据《计算机网络》的举例，假定1200km的传输距离，分组长度1200bit，传输速率1Mb/s， 则信道利用率约为5.66%，传输速率越高则利用率越低。因此，为了提高信道利用率，需要在发送分组和等待确认分组之间连续发送分组，而不是以空闲的状态等待。连续发送分组的数量受到发送方和接收方缓存空间和网络状态的影响，因此使用滑窗协议控制连续发送的字节数。</p><h2 id="滑窗协议的工作方式"><a href="#滑窗协议的工作方式" class="headerlink" title="滑窗协议的工作方式"></a>滑窗协议的工作方式</h2><h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>滑动窗口的含义是：发送方维持一个可以连续发送的字节的序号，在序号范围内的字节可以连续发送，不需要等待确认分组；接收方维持一个已经接收到的字节的序号，对按顺序接收到的最高字节序号进行确认，并缓存未按序接收到的字节。因此，在滑窗协议的作用下，接收方不是对每个分组发送确认分组，而是采用累积确认的方式，对按序接受到的最后一个分组确认，表示此分组之前的所有分组都按序接收到了。这样做的好处是实现简单，缺点是不能反应已经接收到的分组的真实情况。如果发送方发送的分组中的第N个丢失，即使N之后分组被成功接收，也只能收到接收方对N-1和分组的确认，所以发送方需要重新发送从N开始的所有分组，即Go-back-N机制（回退N）。</p><p><img src="/img/滑窗协议/go-back-n.jpg" alt="Go-back-N" title="Go-back-N"></p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>对于发送方来说：发送窗口内的字节可以连续发送，不需要等待B的确认分组。同时已发送但未确认的数据都要保留，以备重新发送。发送窗口图示：</p><p><img src="/img/滑窗协议/tcpswslide_send.png" alt="tcpswslide_send" title="send window"></p><p>可以看见，在发送方窗口中，数据按照发送状态被分为四部分：</p><ul><li>已发送且已收到确认</li><li>已发送但未收到确认</li><li>在发送窗口内但尚未发送</li><li>尚未进入发送窗口</li></ul><p>对于接收方来说：对于接收窗口内的按序收到的最后一个字节发送确认分组给发送方，并且将按序收到的数据交付主机的进程，因此接收窗口中的数据主要包含非按序接收的字节和尚未交付主机进程的数据。接收窗口图示：</p><p><img src="/img/滑窗协议/tcpswslide_accept.png" alt="tcpwslide_accept" title="accept window"></p><p>可以看见，在接收方窗口中，数据也可以按照接收状态分为四部分：</p><ul><li>已收到并发送过确认分组且已交付主机进程</li><li>已收到但未交付主机或非按序字节</li><li>接收窗口中允许继续接收的部分</li><li>尚未进入接收窗口</li></ul><p>根据图示可以看出发送窗口和接收窗口的变化过程，为了方便描述，设发送方为S(send),接收方为A(accept)。假设S发送窗口内的10个字节后，收到A对前5个字节的确认，此时发送窗口向前移动5个字节，相当于扩大了发送窗口中的可发送部分。此时如果第6个字节丢失或在网络中延迟，导致A没有收到它，而是先收到了第7个字节，则A无法对接下来收到的字节发送确认，因为A只能对按序收到的字节确认。S发送窗口中的数据继续发送，可发送区域不断缩小，直到发送窗口中都是已发送但未确认的字节，即发送窗口已满，且没有继续收到A的确认（缺失第6字节），则S必须停止发送。在超时重传机制的作用下，S经过一段时间后会重新发送从第6字节开始的数据，直到收到A的确认，然后继续滑动发送窗口，持续这个动态过程。在接收窗口中，如果检查出收到的分组有错误，则丢弃改分组。对于窗口的工作过程，还有一些要点：</p><ul><li>发送窗口的大小是由接收方说明的，接收方会在TCP数据包的window字段，根据接收窗口的大小指明发送方可以设置的窗口大小。但是发送方的窗口大小不是每时每刻都保持与接收窗口一致。因为网络有延迟，接收方对窗口的调整信息可能不能及时传递到发送方，此外，发送窗口的大小还会根据网络的拥塞情况根据相应算法做调整。</li><li>TCP协议没有对已接收的无序字节的处理作出规定，通常是缓存在接收窗口中，等到缺失的字节到来后组成有序数据，再交付主机进程处理</li><li>TCP规定接收方必须有累积确认机制。接收端可以选择延迟确认，比如在需要发送数据时捎带上确认分组，但是推迟时间不能超过0.5秒。通常这种推迟确认的情况不会发生</li></ul>]]></content>
      
      <categories>
          
          <category> C++服务器设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Reactor模式</title>
      <link href="/2019/01/05/Reactor%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/05/Reactor%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Reactor模式实现I-O复用"><a href="#Reactor模式实现I-O复用" class="headerlink" title="Reactor模式实现I/O复用"></a>Reactor模式实现I/O复用</h1><h2 id="Reactor模式简介"><a href="#Reactor模式简介" class="headerlink" title="Reactor模式简介"></a>Reactor模式简介</h2><p>在网络服务器编程中，一个常见的实际场景是服务器需要与多个套接字连接，如果某个套接字可读，即读取该套接字数据并做相关处理。处理这样场景的最简单思路就是用非阻塞的read对所有套接字轮询，或者使用select和poll进行轮询。因为轮询需要持续查看内核中某个套接字是否就绪，如果连接了大量套接字则每次轮询时间会很长，不利于I/O密集型应用。epoll作为加强版的poll不会随着监听的套接字数量增长而大幅降低效率。epoll也是通常会使用的I/O复用模型，但是epoll作为linux系统调用过于底层，在实际使用中常常对其按照某种事件处理机制进一步封装。一种常用的事件处理机制工作方式如下描述：</p><p>服务器连接的套接字可以抽象为事件源，每个事件对应的处理函数可以抽象为事件处理器，在事件源和事件处理器之间需要一个事件分离器进行分配，将每个事件分配到对应的事件处理器中进行处理。事件分离器用epoll实现。应用程序事先在事件分离器中注册相应的事件处理器，当事件发生时，epoll将该事件分配到已注册的事件处理器中进行处理，由事件处理器完成实际的读写。这种事件处理机制就是Reactor模式。<br>Reactor的核心在于以事件为驱动，而不是主动调用处理函数等待事件发生。在Reactor模式中，应用程序需要先注册好处理事件的接口，当事件发生时回调已经注册好的处理函数进行处理。这种被动调用的方式有如下优点：</p><ul><li>响应速度快；</li><li>可扩展性强，能够方便的增加Reactor实例个数来充分利用CPU资源；</li><li>可复用性强，Reactor与具体的业务逻辑无关，只与I/O调度有关，具有很高的复用性；</li><li>编程简单，避免了多线程/多进程的切换开销。</li></ul><h2 id="Reactor模式组成"><a href="#Reactor模式组成" class="headerlink" title="Reactor模式组成"></a>Reactor模式组成</h2><p><img src="/img/Reactor/Reactor_component.png" alt="Reactor的组成" title="Reactor的组成"></p><p>如图中所示，Reactor为时间反应器， Event Handler为时间处理器，Event Demultiplexer为时间分离器， Concrete Event Handler封装时间处理器， Handle为时间源。</p><ul><li>事件源（handler）：一般是描述符，由操作系统提供。可以使socket，文件描述符等。可以来自系统内部，也可以来自系统内部；</li><li>事件反应器（Reactor）：是Reactor模式的核心，负责应用程序控制事件的调度。包括应用程序的注册，删除事件处理器和相关描述符的接口。它使用事件分离器等待事件的发生，事件发生时，事件分离器会回调事先注册好的回调函数来处理对应事件；</li><li>事件分离器（Event Demultiplexer）：一般由epoll实现，调用者会被阻塞直到事件分离器上注册的事件发生；</li><li>事件处理器（Event Handler）：提供了一组能够处理对应事件的接口，这组接口事先由应用程序注册。</li></ul><h2 id="Reactor事件处理流程"><a href="#Reactor事件处理流程" class="headerlink" title="Reactor事件处理流程"></a>Reactor事件处理流程</h2><p>首先是事件注册部分，应用程序将期待注册的套接字描述符作为事件源，将对应的回调函数和该描述符注册到事件处理器上，然后将该事件处理器注册到事件反应器上。事件反应器将注册信息再次注册到事件分离器epoll中，在epoll中通过epoll_ctl进行添加描述符及事件，并层层返回注册结果；<br>然后是事件处理部分，事件反应器通过epoll_wait等待注册事件发生。一旦事件真的发生，epoll_wait将会返回，并将包含该事件的事件集返回到事件反应器，反应器根据事件源找到该事件的处理器，并根据事件类型调用之前在事件处理器中注册的回调函数，在回调函数中完成事件的处理。<br>根据Reactor模式的具体流程可知，应用程序只参与了最初的注册步骤，具体的等待事件发生和事件处理都由Reactor分配。因此， 在Reactor模式中，应用程序无须关心事件的来源和发生时间，只要完成回调函数和描述符的注册即可，事件的处理流程被Reactor控制翻转了。这一特性对应了设计模式中的好莱坞原则。</p><h2 id="Reactor的使用"><a href="#Reactor的使用" class="headerlink" title="Reactor的使用"></a>Reactor的使用</h2><p><img src="/img/Reactor/Reactor_use.png" alt="Reactor的事件循环" title="Reactor的使用"></p><p>在初始化阶段， 我们将服务器监听套接字及对应的处理函数注册到Reactor中，然后系统进入Reactor的大循环中等待事件的发生。<br>接下来，如果发生监听套接字可读事件，则表示有新连接产生。Reactor回调之前注册好的回调函数，即通过accept系统调用获取新连接的套接字，并将该连接的描述符和对应的处理函数注册到Reactor中。执行完监听套接字的处理函数后，若仍有事件未处理，则继续进入该事件对应的回调函数中进行处理；否则进入下一次事件循环中，继续调用epoll阻塞等待事件的发生；<br>这时，Reactor上已经注册了两类事件：监听套接字可读事件（代表新连接的产生）和连接套接字可读事件（代表有从客户端发来的数据）。<br>在接下来的循环中，如果到达的事件是监听套接字事件，则重复上面的步骤；若到达的是连接套接字事件，则Reactor会回调对应的连接套接字Handler。在这次调用中，先通过read系统调用读取收到的数据，然后进行具体的处理。处理结束后若还有事件待处理，则继续处理，否则进入下次循环，epoll阻塞等待事件的发生。<br>以上描述的是单线程中服务器使用Reactor模式建立新的客户端连接并接受、处理客户端数据的工作。Reactor满足了高并发和高性能的需求，同时实现了网络细节与业务逻辑的分离。在使用中只需要在不同事件对应的Handler中实现具体的业务逻辑即可。</p>]]></content>
      
      <categories>
          
          <category> C++服务器设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（转载）C++虚函数表解析</title>
      <link href="/2018/10/25/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/10/25/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">                                            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e4c7a3727d.css">                        <div class="htmledit_views">                <p class="MsoNormal" style="text-align:center;" align="center"><strong><span style="font-size:24pt;font-family:'新宋体';">C++ <span xml:lang="zh-cn" lang="zh-cn">虚函数表解析<p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><strong><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">陈皓</span></font></strong></p><p><strong></strong></p><strong></strong><p class="MsoNormal" style="text-align:center;" align="center"><a href="http://blog.csdn.net/haoel" rel="nofollow" target="_blank"><font size="3" face="Times New Roman">http://blog.csdn.net/haoel</font></a><strong></strong></p><p><strong></strong></p><strong></strong><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t0"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">前言</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，</span><font face="Times New Roman">RTTI</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家</span><span xml:lang="zh-cn" lang="zh-cn"><font face="Times New Roman"> </font></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">一个清晰的剖析。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">言归正传，让我们一起进入虚函数的世界。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t1"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">虚函数表</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">对</span><font face="Times New Roman">C++ </font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">了解的人都应该知道虚函数（</span><font face="Times New Roman">Virtual Function</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">）是通过一张虚函数表（</span><font face="Times New Roman">Virtual Table</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">）来实现的。简称为</span><font face="Times New Roman">V-Table</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">这里我们着重看一下这张虚函数表。</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。</span><span xml:lang="zh-cn" lang="zh-cn"><font face="Times New Roman"> </font></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。</span><span xml:lang="zh-cn" lang="zh-cn"><font face="Times New Roman"> </font></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">没关系，下面就是实际的例子，相信聪明的你一看就明白了。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">假设我们有这样的一个类：</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:10pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:10pt;font-family:Tahoma;"> Base {</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;color:#0000FF;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>public</span><span style="font-size:10pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Base::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> g() { cout &lt;&lt; <span style="color:#808000;">"Base::g"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> h() { cout &lt;&lt; <span style="color:#808000;">"Base::h"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:10pt;font-family:Tahoma;">};</span><span style="font-size:10pt;font-family:Tahoma;"></span></p><p></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">按照上面的说法，我们可以通过</span><font face="Times New Roman">Base</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的实例来得到虚函数表。</span><span xml:lang="zh-cn" lang="zh-cn"><font face="Times New Roman"> </font></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">下面是实际例程：</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:Tahoma;"><span><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span></span><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">typedef</span><span style="font-size:9pt;font-family:Tahoma;"> <span style="color:#0000FF;">void</span>(*Fun)(<span style="color:#0000FF;">void</span>);</span></p><p></p><p class="MsoNormal"><span style="font-family:Tahoma;"></span></p><p><font size="3">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Base b;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Fun pFun = NULL;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout &lt;&lt; <span style="color:#808000;">"</span></span><span style="font-size:9pt;color:#808000;font-family:Fixedsys;" xml:lang="zh-cn" lang="zh-cn">虚函数表地址：</span><span style="font-size:9pt;color:#808000;font-family:Tahoma;">"</span><span style="font-size:9pt;font-family:Tahoma;"> &lt;&lt; (<span style="color:#0000FF;">int</span>*)(&amp;b) &lt;&lt; endl;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout &lt;&lt; <span style="color:#808000;">"</span></span><span style="font-size:9pt;color:#808000;font-family:Fixedsys;" xml:lang="zh-cn" lang="zh-cn">虚函数表</span><span style="font-size:9pt;color:#808000;font-family:Tahoma;"> — </span><span style="font-size:9pt;color:#808000;font-family:Fixedsys;" xml:lang="zh-cn" lang="zh-cn">第一个函数地址：</span><span style="font-size:9pt;color:#808000;font-family:Tahoma;">"</span><span style="font-size:9pt;font-family:Tahoma;"> &lt;&lt; (<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;b) &lt;&lt; endl;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">// Invoke the first virtual function<span>&nbsp; </span></span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)*((<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;b));</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">实际运行经果如下：</span><font face="Times New Roman">(Windows XP+VS2003,<span>&nbsp; </span>Linux 2.6.22 + GCC 4.1.3)</font></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:10pt;color:#333333;font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">虚函数表地址：</span><span style="font-size:10pt;color:#333333;font-family:Tahoma;">0012FED4</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;color:#333333;font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">虚函数表</span><span style="font-size:10pt;color:#333333;font-family:Tahoma;"> — </span><span style="font-size:10pt;color:#333333;font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">第一个函数地址：</span><span style="font-size:10pt;color:#333333;font-family:Tahoma;">0044F148</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;color:#333333;font-family:Tahoma;">Base::f</span></p><p></p><p class="MsoNormal"><span style="font-size:10pt;color:#333333;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:10pt;color:#333333;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">通过这个示例，我们可以看到，我们可以通过强行把</span><font face="Times New Roman">&amp;b</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">转成</span><font face="Times New Roman">int *</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是</span><font face="Times New Roman">Base::f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，这在上面的程序中得到了验证（把</span><font face="Times New Roman">int* </font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用</span><font face="Times New Roman">Base::g()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">和</span><font face="Times New Roman">Base::h()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，其代码如下：</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span><font size="3" face="Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="font-size:9pt;font-family:Tahoma;">(Fun)*((<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;b)+0);<span>&nbsp; </span><span style="color:#008000;">// Base::f()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(Fun)*((<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;b)+1);<span>&nbsp; </span><span style="color:#008000;">// Base::g()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(Fun)*((<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;b)+2);<span>&nbsp; </span><span style="color:#008000;">// Base::h()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#008000;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：</font></span></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3"></font></span></p><p class="MsoNormal" align="center"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable1.jpg"></font></span></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3"></font></span></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3">&lt;?xml:namespace prefix = v /&gt;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“</span><font face="Times New Roman">/0</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在</span><font face="Times New Roman">WinXP+VS2003</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">下，这个值是</span><font face="Times New Roman">NULL</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">。而在</span><font face="Times New Roman">Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">下，这个值是如果</span><font face="Times New Roman">1</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，表示还有下一个虚函数表，如果值是</span><font face="Times New Roman">0</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，表示是最后一个虚函数表。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t2"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">一般继承（无虚函数覆盖）</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" align="center"></p><p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing3.jpg"></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：</font></span></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3"></font></span></p><p class="MsoNormal" align="center"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">对于实例：</span><font face="Times New Roman">Derive d; </font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚函数表如下：</span></font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"></span></font></p><p class="MsoNormal" align="center"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable2.JPG"></span></span></font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3"></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">我们可以看到下面几点：</font></span></p><p class="MsoNormal" style="text-indent:-.25in;"><font size="3"><span><span><font face="Times New Roman">1）</font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">虚函数按照其声明顺序放于表中。</span></font></p><p class="MsoNormal" style="text-indent:-.25in;"><font size="3"><span><span><font face="Times New Roman">2）</font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">父类的虚函数在子类的虚函数前面。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t3"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">一般继承（有虚函数覆盖）</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" align="center"></p><p><font size="3" face="Times New Roman">&nbsp;<img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing4.jpg"></font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal" align="center"></p><p><font size="3" face="Times New Roman"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG"></font></p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman"></font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">我们从表中可以看到下面几点，</font></span></p><p class="MsoNormal" style="text-indent:-.25in;"><font size="3"><span><span><font face="Times New Roman">1）</font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">覆盖的</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">函数被放到了虚表中原来父类虚函数的位置。</span></font></p><p class="MsoNormal" style="text-indent:-.25in;"><font size="3"><span><span><font face="Times New Roman">2）</font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">没有被覆盖的函数依旧。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">这样，我们就可以看到对于下面这样的程序，</font></span></p><p class="MsoNormal"><span style="font-family:Tahoma;"></span></p><p><font size="3">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Base *b = <span style="color:#0000FF;">new</span> Derive();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b-&gt;f();</span><span style="font-family:Tahoma;"></span></p><p></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">由</span><font face="Times New Roman">b</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">所指的内存中的虚函数表的</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的位置已经被</span><font face="Times New Roman">Derive::f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">函数地址所取代，于是在实际调用发生时，是</span><font face="Times New Roman">Derive::f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">被调用了。这就实现了多态。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t4"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">多重继承（无虚函数覆盖）</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p><font size="3" face="Times New Roman"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing1.jpg">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">对于子类实例中的虚函数表，是下面这个样子：</font></span></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3"></font></span></p><p class="MsoNormal" align="center"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable4.JPG"></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">我们可以看到：</font></span></p><p class="MsoNormal" style="text-indent:-21pt;"><span><span><font face="Times New Roman"><font size="3">1）</font><span style="font:7pt 'Times New Roman';">&nbsp; </span></font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">每个父类都有自己的虚表。</font></span></p><p class="MsoNormal" style="text-indent:-21pt;"><span><span><font face="Times New Roman"><font size="3">2）</font><span style="font:7pt 'Times New Roman';">&nbsp; </span></font></span></span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t5"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">多重继承（有虚函数覆盖）</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面我们再来看看，如果发生虚函数覆盖的情况。</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">下图中，我们在子类中覆盖了父类的</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">函数。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p><font size="3" face="Times New Roman"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing2.jpg">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面是对于子类实例中的虚函数表的图：</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3" face="Times New Roman"></font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p><font size="3" face="Times New Roman"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable5.jpg"></font></p><p class="MsoNormal" style="text-align:center;" align="center"></p><p>&nbsp;</p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">我们可以看见，三个父类虚函数表中的</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的</span><font face="Times New Roman">f()</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">了。如：</span></font></p><p class="MsoNormal"><span style="font-family:Tahoma;"></span></p><p><font size="3">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Derive d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Base1 *b1 = &amp;d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Base2 *b2 = &amp;d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Base3 *b3 = &amp;d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b1-&gt;f(); <span style="color:#008000;">//Derive::f()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b2-&gt;f(); <span style="color:#008000;">//Derive::f()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b3-&gt;f(); <span style="color:#008000;">//Derive::f()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#008000;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b1-&gt;g(); <span style="color:#008000;">//Base1::g()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b2-&gt;g(); <span style="color:#008000;">//Base2::g()</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b3-&gt;g(); <span style="color:#008000;">//Base3::g()</span></span><span style="font-family:Tahoma;"></span></p><p></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t6"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">安全性</font></span></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">每次写</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的文章，总免不了要批判一下</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><strong><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">一、通过父类型的指针访问子类自己的虚函数</span></font></strong></p><p><strong></strong></p><strong></strong><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到</span><font face="Times New Roman">Base1</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚表中有</span><font face="Times New Roman">Derive</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：</span></font></p><p class="MsoNormal"><span style="font-family:Tahoma;"></span></p><p><font size="3">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:Tahoma;"><span><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span></span><span style="font-size:9pt;font-family:Tahoma;">Base1 *b1 = <span style="color:#0000FF;">new</span> Derive();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b1-&gt;f1();<span>&nbsp; </span></span><span style="font-size:9pt;color:#008000;font-family:Fixedsys;">//<span xml:lang="zh-cn" lang="zh-cn">编译出错</span></span><span style="font-family:Tahoma;"></span></p><p></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">任何妄图使用父类指针想调用子类中的<strong>未覆盖父类的成员函数</strong>的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><strong><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">二、访问</span><font face="Times New Roman">non-public</font></strong><strong><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚函数</span></strong></font></p><p><strong></strong></p><strong></strong><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">另外，如果父类的虚函数是</span><font face="Times New Roman">private</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">或是</span><font face="Times New Roman">protected</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的，但这些非</span><font face="Times New Roman">public</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些</span><font face="Times New Roman">non-public</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的虚函数，这是很容易做到的。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">如：</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Base {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp; </span>private</span><span style="font-size:9pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Base::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span><span style="font-family:Tahoma;"></span></p><p></p><p class="MsoNormal"><span style="font-family:Tahoma;"></span></p><p><font size="3">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Derive : <span style="color:#0000FF;">public</span> Base{</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">typedef</span><span style="font-size:9pt;font-family:Tahoma;"> <span style="color:#0000FF;">void</span>(*Fun)(<span style="color:#0000FF;">void</span>);</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">void</span><span style="font-size:9pt;font-family:Tahoma;"> main() {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp; </span>Derive d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp; </span>Fun<span>&nbsp; </span>pFun = (Fun)*((<span style="color:#0000FF;">int</span>*)*(<span style="color:#0000FF;">int</span>*)(&amp;d)+<span style="color:#800080;">0</span>);</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">}</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><h1><a name="t7"></a><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="5">结束语</font></span></h1><p class="MsoNormal"><font size="3"><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">这门语言是一门</span><font face="Times New Roman">Magic</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">里面的那些东西，需要去了解</span><font face="Times New Roman">C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。</span></font></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">在文章束之前还是介绍一下自己吧。我从事软件研发有十个年头了，目前是软件开发技术主管，技术方面，主攻</span><font face="Times New Roman">Unix/C/C++</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，比较喜欢网络上的技术，比如分布式计算，网格计算，</span><font face="Times New Roman">P2P</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">，</span><font face="Times New Roman">Ajax</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">等一切和互联网相关的东西。管理方面比较擅长于团队建设，技术趋势分析，项目管理。欢迎大家和我交流，我的</span><font face="Times New Roman">MSN</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">和</span><font face="Times New Roman">Email</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">是：</span></font><a href="mailto:haoel@hotmail.com" rel="nofollow" target="_blank"><font size="3" face="Times New Roman">haoel@hotmail.com</font></a><span><font size="3" face="Times New Roman">&nbsp; </font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><h1><a name="t8"></a><font size="5"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">附录一：</span>VC<span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">中查看虚函数表</span></font></h1><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">我们可以在</span><font face="Times New Roman">VC</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">的</span><font face="Times New Roman">IDE</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">环境中的</span><font face="Times New Roman">Debug</font><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">状态下展开类的实例就可以看到虚函数表了（并不是很完整的）</span></font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"></span></font></p><p class="MsoNormal" align="center"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable_vc.JPG"></span></font></p><p class="MsoNormal" style="text-align:center;" align="center"><font size="3"></font></p><h1><a name="t9"></a><font size="5"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">附录</span><span xml:lang="zh-cn" lang="zh-cn"> </span><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">二：例程</span></font></h1><p class="MsoNormal"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn"><font size="3">下面是一个关于多重继承的虚函数表访问的例程：</font></span></p><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">#include</span><span style="font-size:9pt;font-family:Tahoma;"> <span style="color:#808000;">&lt;iostream&gt;</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">using</span><span style="font-size:9pt;font-family:Tahoma;"> <span style="color:#0000FF;">namespace</span> std;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Base1 {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">public</span><span style="font-size:9pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Base1::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> g() { cout &lt;&lt; <span style="color:#808000;">"Base1::g"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> h() { cout &lt;&lt; <span style="color:#808000;">"Base1::h"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Base2 {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">public</span><span style="font-size:9pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Base2::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> g() { cout &lt;&lt; <span style="color:#808000;">"Base2::g"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> h() { cout &lt;&lt; <span style="color:#808000;">"Base2::h"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Base3 {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">public</span><span style="font-size:9pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Base3::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> g() { cout &lt;&lt; <span style="color:#808000;">"Base3::g"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> h() { cout &lt;&lt; <span style="color:#808000;">"Base3::h"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">class</span><span style="font-size:9pt;font-family:Tahoma;"> Derive : <span style="color:#0000FF;">public</span> Base1, <span style="color:#0000FF;">public</span> Base2, <span style="color:#0000FF;">public</span> Base3 {</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">public</span><span style="font-size:9pt;font-family:Tahoma;">:</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> f() { cout &lt;&lt; <span style="color:#808000;">"Derive::f"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">virtual</span> <span style="color:#0000FF;">void</span> g1() { cout &lt;&lt; <span style="color:#808000;">"Derive::g1"</span> &lt;&lt; endl; }</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">};</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">typedef</span><span style="font-size:9pt;font-family:Tahoma;"> <span style="color:#0000FF;">void</span>(*Fun)(<span style="color:#0000FF;">void</span>);</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;color:#0000FF;font-family:Tahoma;">int</span><span style="font-size:9pt;font-family:Tahoma;"> main() </span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">{</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Fun pFun = NULL;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Derive d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">int</span>** pVtab = (<span style="color:#0000FF;">int</span>**)&amp;d;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;color:#008000;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#008000;">//Base1's vtable</span></strong></span></p><p><strong></strong></p><strong></strong><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">0</span>][<span style="color:#800080;">0</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">0</span>][<span style="color:#800080;">1</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">0</span>][<span style="color:#800080;">2</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//Derive's vtable</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">0</span>][<span style="color:#800080;">3</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//The tail of the vtable</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">0</span>][<span style="color:#800080;">4</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout&lt;&lt;pFun&lt;&lt;endl;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#008000;">//Base2's vtable</span></strong></span></p><p><strong></strong></p><strong></strong><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">1</span>][<span style="color:#800080;">0</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">1</span>][<span style="color:#800080;">1</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">1</span>][<span style="color:#800080;">2</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun(); </span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//The tail of the vtable</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">1</span>][<span style="color:#800080;">3</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout&lt;&lt;pFun&lt;&lt;endl;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#008000;">//Base3's vtable</span></strong></span></p><p><strong></strong></p><strong></strong><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">2</span>][<span style="color:#800080;">0</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">2</span>][<span style="color:#800080;">1</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun();</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">2</span>][<span style="color:#800080;">2</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun(); </span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#008000;">//The tail of the vtable</span></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pFun = (Fun)pVtab[<span style="color:#800080;">2</span>][<span style="color:#800080;">3</span>];</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cout&lt;&lt;pFun&lt;&lt;endl;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"></span></p><p>&nbsp;</p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#0000FF;">return</span> <span style="color:#800080;">0</span>;</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Tahoma;">}</span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:Fixedsys;"></span></p><p>&nbsp;</p><p class="MsoNormal"><font size="3"><strong><font face="Times New Roman">(</font></strong><strong><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">转载时请注明作者和出处。未经许可，请勿用于商业用途</span><font face="Times New Roman">)</font></strong></font></p><p><strong></strong></p><strong></strong><p class="MsoNormal"></p><p><font size="3" face="Times New Roman">&nbsp;</font></p><p class="MsoNormal"><font size="3"><span style="font-family:'宋体';" xml:lang="zh-cn" lang="zh-cn">更多文章请访问我的</span><font face="Times New Roman">Blog: </font></font><a href="http://blog.csdn.net/haoel" rel="nofollow" target="_blank"><font size="3" face="Times New Roman">http://blog.csdn.net/haoel</font></a><font size="3" face="Times New Roman"> </font></p>&nbsp;            </span></span></strong></p></div>                </div>]]></content>
      
      
    </entry>
    
    <entry>
      <title>C++中的int, long, long long</title>
      <link href="/2018/10/24/C-%E4%B8%AD%E7%9A%84int-long-long-long/"/>
      <url>/2018/10/24/C-%E4%B8%AD%E7%9A%84int-long-long-long/</url>
      <content type="html"><![CDATA[<h1 id="C-中的int-long-long-long"><a href="#C-中的int-long-long-long" class="headerlink" title="C++中的int, long, long long"></a>C++中的int, long, long long</h1><p>C++中的三种整数数据类型，int， long， long long是平时极为常用的类型，在此总结一下它们的用法。</p><p> int， long，和long long之间可以隐式转换，规则为从取值范围小到取值范围大的转换，例如int&gt;long</p><p> 三者占用的空间，根据《C++ primer》算数类型的尺寸根据不同的机器和编译器会有所差别。C++只规定了最小尺寸，允许编译器赋予更大的尺寸。</p><div class="table-container"><table><thead><tr><th>类型</th><th>最小尺寸</th></tr></thead><tbody><tr><td>short</td><td>16位</td></tr><tr><td>int</td><td>16位</td></tr><tr><td>long</td><td>32位</td></tr><tr><td>long long</td><td>64位</td></tr></tbody></table></div><p>C++语言规定int至少和short一样大，long至少和int一样大， long long 至少和long一样大。其中long long是C++11中新定义的。通常来讲，short是半个机器字长，int是一个机器字长， long是一到两个机器字长， long long在任何环境下都是8个字节。</p><p>一般情况下，32位系统中short为2个字节，int为4个字节，long与int相同为4个字节， long long为8个字节；64位系统中short依然为2个字节，为了向前兼容，int也会被编译为4个字节，long为8个字节，long long为8个字节。</p><p>所以在实际使用中，不同的编译器对算数类型的处理可能会有差别，在不同系统和编译器中得到的算数类型尺寸不一定相同，除了short是稳定的2个字节，以及long long是稳定的8个字节。所以在需要获取算数类型尺寸的时候最好用sizeof()， 而不是凭经验认定int就是4个字节或long就是8个字节, 实际上long与int尺寸相同的情况很常见。需要扩大尺寸的话尽量用long long，可以保证是8个字节。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列</title>
      <link href="/2018/08/23/Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97/"/>
      <url>/2018/08/23/Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock系列"><a href="#Leetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock系列" class="headerlink" title="Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列"></a>Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列</h1><ol><li><h2 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p> Note that you cannot sell a stock before you buy one.</p><p> Example 1:</p><p> Input: [7,1,5,3,6,4]<br> Output: 5<br> Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</p><pre><code>         Not 7-1 = 6, as selling price needs to be larger than buying price.</code></pre><p> Example 2:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0, buy = INT_MAX;</span><br><span class="line">    for(int price:prices)</span><br><span class="line">    &#123;</span><br><span class="line">        buy = min(buy, price);</span><br><span class="line">        res = max(price - buy, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a>Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p><p> Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [7,1,5,3,6,4]<br> Output: 7<br> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</p><pre><code>         Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</code></pre><p> Example 2:</p><p> Input: [1,2,3,4,5]<br> Output: 4<br> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</p><pre><code>         Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are         engaging multiple transactions at the same time. You must sell before buying again.</code></pre><p> Example 3:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 本题有两种思路。</p><p> 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res = 0, n = prices.size();</span><br><span class="line">        for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">            if (prices[i] &lt; prices[i + 1]) &#123;</span><br><span class="line">                res += prices[i + 1] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int buy = INT_MIN, sell = 0;</span><br><span class="line">        int prebuy = 0, presell = 0;</span><br><span class="line">        for(int price : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            prebuy = buy;</span><br><span class="line">            presell = sell;</span><br><span class="line">            buy = max(presell - price, prebuy);</span><br><span class="line">            sell = max(prebuy + price, presell);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = sell;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p> Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [3,3,5,0,0,3,1,4]<br> Output: 6<br> Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</p><pre><code>         Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</code></pre><p> Example 2:</p><p> Input: [1,2,3,4,5]<br> Output: 4<br> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</p><pre><code>         Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are         engaging multiple transactions at the same time. You must sell before buying again.</code></pre><p> Example 3:</p><p> Input: [7,6,4,3,1]<br> Output: 0<br> Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p> 感觉这道题目解法不是很好理解，参考<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a>的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用”局部最优和全局最优”的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为</p><p> local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit);</p><p> global[i][j] = max(global[i-1][j], local[i][j]);</p><p> 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在</p><p> local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit)</p><p>  中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。</p><p> 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。</p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.size(); </span><br><span class="line">        int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int diff = prices[i] - prices[i-1];</span><br><span class="line">            for(int j = 1; j &lt;= 2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff);    //由局部的极值推导全局最值</span><br><span class="line">                g[i][j] = max(g[i-1][j], l[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[n-1][2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a></p><p> C++</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">        if (prices.empty()) return 0;</span><br><span class="line">        int g[3] = &#123;0&#125;;</span><br><span class="line">        int l[3] = &#123;0&#125;;</span><br><span class="line">        for (int i = 0; i &lt; prices.size() - 1; ++i) &#123;</span><br><span class="line">            int diff = prices[i + 1] - prices[i];</span><br><span class="line">            for (int j = 2; j &gt;= 1; --j) &#123;</span><br><span class="line">                l[j] = max(g[j - 1] + diff, l[j] + diff);</span><br><span class="line">                g[j] = max(l[j], g[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。</p></li><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a>Best Time to Buy and Sell Stock IV</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete at most k transactions.</p><p> Note:<br> You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p> Example 1:</p><p> Input: [2,4,1], k = 2<br> Output: 2<br> Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</p><p> Example 2:</p><p> Input: [3,2,6,5,0,3], k = 2<br> Output: 7<br> Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</p><pre><code>         Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</code></pre></li></ol><pre><code>这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。C++<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size() == 1||prices.empty() ||k == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &gt;= prices.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return maxProfit_1(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        vector&lt;int&gt; g(k+1, 0);</span><br><span class="line">        vector&lt;int&gt; l(k+1, 0);</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int diff = prices[i] - prices[i-1];</span><br><span class="line">            for(int j = k; j &gt;=1; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                l[j] = max(g[j-1]+diff, l[j]+diff);</span><br><span class="line">                g[j] = max(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxProfit_1(vector&lt;int&gt;&amp; prices)</span><br><span class="line">    &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i] &gt;prices[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                res += (prices[i] - prices[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ol><li><h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a>Best Time to Buy and Sell Stock with Cooldown</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><pre><code> You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</code></pre><p> Example:</p><p> Input: [1,2,3,0,2]<br> Output: 3<br> Explanation: transactions = [buy, sell, cooldown, buy, sell]</p><p> 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考<a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">Grandyang</a>的方法，维护三个数组buy[],sell[]和rest[]。</p></li></ol><pre><code>其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为：buy[i] = max(rest[i-1]-price, buy[i-1]);sell[i] = max(buy[i-1]+price, sell[i-1]);rest[i] = max(buy[i-1], sell[i-1], rest[i-1]);上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以rest[i] = max(sell[i-1], rest[i-1]);此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为buy[i] = max(sell[i-2]-price, buy[i-1]);sell[i] = max(buy[i-1]+price, sell[i-1]);可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。C++<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            pre_buy = buy;</span><br><span class="line">            buy = max(pre_sell - price, pre_buy);</span><br><span class="line">            pre_sell = sell;</span><br><span class="line">            sell = max(pre_buy + price, pre_sell);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。[Grandyang](http://www.cnblogs.com/grandyang/p/4281975.html)的博客给我提供了很大帮助。</code></pre>]]></content>
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
