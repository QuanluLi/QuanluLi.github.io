<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Reactor模式]]></title>
    <url>%2F2019%2F01%2F05%2FReactor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reactor模式实现I/O复用Reactor模式简介在网络服务器编程中，一个常见的实际场景是服务器需要与多个套接字连接，如果某个套接字可读，即读取该套接字数据并做相关处理。处理这样场景的最简单思路就是用非阻塞的read对所有套接字轮询，或者使用select和poll进行轮询。因为轮询需要持续查看内核中某个套接字是否就绪，如果连接了大量套接字则每次轮询时间会很长，不利于I/O密集型应用。epoll作为加强版的poll不会随着监听的套接字数量增长而大幅降低效率。epoll也是通常会使用的I/O复用模型，但是epoll作为linux系统调用过于底层，在实际使用中常常对其按照某种事件处理机制进一步封装。一种常用的事件处理机制工作方式如下描述： 服务器连接的套接字可以抽象为事件源，每个事件对应的处理函数可以抽象为事件处理器，在事件源和事件处理器之间需要一个事件分离器进行分配，将每个事件分配到对应的事件处理器中进行处理。事件分离器用epoll实现。应用程序事先在事件分离器中注册相应的事件处理器，当事件发生时，epoll将该事件分配到已注册的事件处理器中进行处理，由事件处理器完成实际的读写。这种事件处理机制就是Reactor模式。 Reactor的核心在于以事件为驱动，而不是主动调用处理函数等待事件发生。在Reactor模式中，应用程序需要先注册好处理事件的接口，当事件发生时回调已经注册好的处理函数进行处理。这种被动调用的方式有如下优点： 响应速度快； 可扩展性强，能够方便的增加Reactor实例个数来充分利用CPU资源； 可复用性强，Reactor与具体的业务逻辑无关，只与I/O调度有关，具有很高的复用性； 编程简单，避免了多线程/多进程的切换开销。 Reactor模式组成 如图中所示，Reactor为时间反应器， Event Handler为时间处理器，Event Demultiplexer为时间分离器， Concrete Event Handler封装时间处理器， Handle为时间源。 事件源（handler）：一般是描述符，由操作系统提供。可以使socket，文件描述符等。可以来自系统内部，也可以来自系统内部； 事件反应器（Reactor）：是Reactor模式的核心，负责应用程序控制事件的调度。包括应用程序的注册，删除事件处理器和相关描述符的接口。它使用事件分离器等待事件的发生，事件发生时，事件分离器会回调事先注册好的回调函数来处理对应事件； 事件分离器（Event Demultiplexer）：一般由epoll实现，调用者会被阻塞直到事件分离器上注册的事件发生； 事件处理器（Event Handler）：提供了一组能够处理对应事件的接口，这组接口事先由应用程序注册。 Reactor事件处理流程首先是事件注册部分，应用程序将期待注册的套接字描述符作为事件源，将对应的回调函数和该描述符注册到事件处理器上，然后将该事件处理器注册到事件反应器上。事件反应器将注册信息再次注册到事件分离器epoll中，在epoll中通过epoll_ctl进行添加描述符及事件，并层层返回注册结果； 然后是事件处理部分，事件反应器通过epoll_wait等待注册事件发生。一旦事件真的发生，epoll_wait将会返回，并将包含该事件的事件集返回到事件反应器，反应器根据事件源找到该事件的处理器，并根据事件类型调用之前在事件处理器中注册的回调函数，在回调函数中完成事件的处理。 根据Reactor模式的具体流程可知，应用程序只参与了最初的注册步骤，具体的等待事件发生和事件处理都由Reactor分配。因此， 在Reactor模式中，应用程序无须关心事件的来源和发生时间，只要完成回调函数和描述符的注册即可，事件的处理流程被Reactor控制翻转了。这一特性对应了设计模式中的好莱坞原则。 Reactor的使用 在初始化阶段， 我们将服务器监听套接字及对应的处理函数注册到Reactor中，然后系统进入Reactor的大循环中等待事件的发生。 接下来，如果发生监听套接字可读事件，则表示有新连接产生。Reactor回调之前注册好的回调函数，即通过accept系统调用获取新连接的套接字，并将该连接的描述符和对应的处理函数注册到Reactor中。执行完监听套接字的处理函数后，若仍有事件未处理，则继续进入该事件对应的回调函数中进行处理；否则进入下一次事件循环中，继续调用epoll阻塞等待事件的发生； 这时，Reactor上已经注册了两类事件：监听套接字可读事件（代表新连接的产生）和连接套接字可读事件（代表有从客户端发来的数据）。 在接下来的循环中，如果到达的事件是监听套接字事件，则重复上面的步骤；若到达的是连接套接字事件，则Reactor会回调对应的连接套接字Handler。在这次调用中，先通过read系统调用读取收到的数据，然后进行具体的处理。处理结束后若还有事件待处理，则继续处理，否则进入下次循环，epoll阻塞等待事件的发生。 以上描述的是单线程中服务器使用Reactor模式建立新的客户端连接并接受、处理客户端数据的工作。Reactor满足了高并发和高性能的需求，同时实现了网络细节与业务逻辑的分离。在使用中只需要在不同事件对应的Handler中实现具体的业务逻辑即可。]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>C++服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转载）C++虚函数表解析]]></title>
    <url>%2F2018%2F10%2F25%2F%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[C++ 虚函数表解析&nbsp;陈皓http://blog.csdn.net/haoel&nbsp;&nbsp;前言&nbsp;C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。&nbsp;&nbsp;关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。&nbsp;当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。&nbsp;言归正传，让我们一起进入虚函数的世界。&nbsp;&nbsp;虚函数表&nbsp;对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。&nbsp;这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。&nbsp;听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。&nbsp;假设我们有这样的一个类：&nbsp;class Base {&nbsp;&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Base::f” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; “Base::g” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; “Base::h” &lt;&lt; endl; }&nbsp;};&nbsp;按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef void(Fun)(void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; “虚函数表地址：“ &lt;&lt; (int)(&amp;b) &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; “虚函数表 — 第一个函数地址：“ &lt;&lt; (int)(int)(&amp;b) &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Invoke the first virtual function&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)((int)(int)(&amp;b));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;实际运行经果如下：(Windows XP+VS2003,&nbsp; Linux 2.6.22 + GCC 4.1.3)&nbsp;虚函数表地址：0012FED4虚函数表 — 第一个函数地址：0044F148Base::f&nbsp;&nbsp;通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int ，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)((int)(int)(&amp;b)+0);&nbsp; // Base::f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)((int)(int)(&amp;b)+1);&nbsp; // Base::g()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)((int)(int)(&amp;b)+2);&nbsp; // Base::h()&nbsp;这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：&lt;?xml:namespace prefix = v /&gt;注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。&nbsp;&nbsp;下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。&nbsp;一般继承（无虚函数覆盖）&nbsp;下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：&nbsp;&nbsp;请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：&nbsp;对于实例：Derive d; 的虚函数表如下：&nbsp;我们可以看到下面几点：1）虚函数按照其声明顺序放于表中。2）父类的虚函数在子类的虚函数前面。&nbsp;我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。&nbsp;&nbsp;&nbsp;一般继承（有虚函数覆盖）&nbsp;覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。&nbsp;&nbsp;&nbsp;为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：&nbsp;&nbsp;我们从表中可以看到下面几点，1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。2）没有被覆盖的函数依旧。&nbsp;这样，我们就可以看到对于下面这样的程序，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base b = new Derive();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;f();&nbsp;由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。&nbsp;&nbsp;&nbsp;多重继承（无虚函数覆盖）&nbsp;下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。&nbsp;&nbsp;&nbsp;对于子类实例中的虚函数表，是下面这个样子：&nbsp;我们可以看到：1）&nbsp; 每个父类都有自己的虚表。2）&nbsp; 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）&nbsp;这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。&nbsp;&nbsp;&nbsp;&nbsp;多重继承（有虚函数覆盖）&nbsp;下面我们再来看看，如果发生虚函数覆盖的情况。&nbsp;下图中，我们在子类中覆盖了父类的f()函数。&nbsp;&nbsp;&nbsp;下面是对于子类实例中的虚函数表的图：&nbsp;&nbsp;我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 b1 = &amp;d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base2 b2 = &amp;d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base3 b3 = &amp;d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f(); //Derive::f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;f(); //Derive::f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;f(); //Derive::f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;g(); //Base1::g()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;g(); //Base2::g()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;g(); //Base3::g()&nbsp;&nbsp;安全性&nbsp;每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。&nbsp;一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 b1 = new Derive();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f1();&nbsp; //编译出错&nbsp;任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）&nbsp;&nbsp;二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。&nbsp;如：&nbsp;class Base {&nbsp;&nbsp;&nbsp; private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Base::f” &lt;&lt; endl; }&nbsp;};&nbsp;class Derive : public Base{&nbsp;};&nbsp;typedef void(Fun)(void);&nbsp;void main() {&nbsp;&nbsp;&nbsp; Derive d;&nbsp;&nbsp;&nbsp; Fun&nbsp; pFun = (Fun)((int)(int)(&amp;d)+0);&nbsp;&nbsp;&nbsp; pFun();}&nbsp;&nbsp;结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。&nbsp;在文章束之前还是介绍一下自己吧。我从事软件研发有十个年头了，目前是软件开发技术主管，技术方面，主攻Unix/C/C++，比较喜欢网络上的技术，比如分布式计算，网格计算，P2P，Ajax等一切和互联网相关的东西。管理方面比较擅长于团队建设，技术趋势分析，项目管理。欢迎大家和我交流，我的MSN和Email是：haoel@hotmail.com&nbsp; &nbsp;附录一：VC中查看虚函数表&nbsp;我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的）附录 二：例程下面是一个关于多重继承的虚函数表访问的例程：&nbsp;#include &lt;iostream&gt;using namespace std;&nbsp;class Base1 {public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Base1::f” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; “Base1::g” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; “Base1::h” &lt;&lt; endl; }&nbsp;};&nbsp;class Base2 {public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Base2::f” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; “Base2::g” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; “Base2::h” &lt;&lt; endl; }};&nbsp;class Base3 {public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Base3::f” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; “Base3::g” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; “Base3::h” &lt;&lt; endl; }};&nbsp;&nbsp;class Derive : public Base1, public Base2, public Base3 {public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; “Derive::f” &lt;&lt; endl; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g1() { cout &lt;&lt; “Derive::g1” &lt;&lt; endl; }};&nbsp;&nbsp;typedef void(Fun)(void);&nbsp;int main() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pVtab = (int)&amp;d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base1’s vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+0)+0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+0)+1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+0)+2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Derive’s vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+0)+3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base2’s vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+1)+0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+1)+1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base3’s vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+1)+0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)((int)(int)((int)&amp;d+1)+1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;}&nbsp;(转载时请注明作者和出处。未经许可，请勿用于商业用途)&nbsp;更多文章请访问我的Blog: http://blog.csdn.net/haoel &nbsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++中的int, long, long long]]></title>
    <url>%2F2018%2F10%2F24%2FC-%E4%B8%AD%E7%9A%84int-long-long-long%2F</url>
    <content type="text"><![CDATA[C++中的int, long, long longC++中的三种整数数据类型，int， long， long long是平时极为常用的类型，在此总结一下它们的用法。 int， long，和long long之间可以隐式转换，规则为从取值范围小到取值范围大的转换，例如int&gt;long 三者占用的空间，根据《C++ primer》算数类型的尺寸根据不同的机器和编译器会有所差别。C++只规定了最小尺寸，允许编译器赋予更大的尺寸。 类型 最小尺寸 short 16位 int 16位 long 32位 long long 64位 C++语言规定int至少和short一样大，long至少和int一样大， long long 至少和long一样大。其中long long是C++11中新定义的。通常来讲，short是半个机器字长，int是一个机器字长， long是一到两个机器字长， long long在任何环境下都是8个字节。 一般情况下，32位系统中short为2个字节，int为4个字节，long与int相同为4个字节， long long为8个字节；64位系统中short依然为2个字节，为了向前兼容，int也会被编译为4个字节，long为8个字节，long long为8个字节。 所以在实际使用中，不同的编译器对算数类型的处理可能会有差别，在不同系统和编译器中得到的算数类型尺寸不一定相同，除了short是稳定的2个字节，以及long long是稳定的8个字节。所以在需要获取算数类型尺寸的时候最好用sizeof()， 而不是凭经验认定int就是4个字节或long就是8个字节, 实际上long与int尺寸相同的情况很常见。需要扩大尺寸的话尽量用long long，可以保证是8个字节。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列]]></title>
    <url>%2F2018%2F08%2F23%2FLeetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列 Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。 C++ 123456789101112class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, buy = INT_MAX; for(int price:prices) &#123; buy = min(buy, price); res = max(price - buy, res); &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 本题有两种思路。 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。 C++ 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, n = prices.size(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res += prices[i + 1] - prices[i]; &#125; &#125; return res; &#125;&#125;; 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。 C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, sell = 0; int prebuy = 0, presell = 0; for(int price : prices) &#123; prebuy = buy; presell = sell; buy = max(presell - price, prebuy); sell = max(prebuy + price, presell); &#125; int res = sell; return res; &#125;&#125;; Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 感觉这道题目解法不是很好理解，参考Grandyang的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用”局部最优和全局最优”的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit); global[i][j] = max(global[i-1][j], local[i][j]); 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit) 中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。 C++ 123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) &#123; return 0; &#125; int n = prices.size(); int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;; for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = 1; j &lt;= 2; ++j) &#123; l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff); //由局部的极值推导全局最值 g[i][j] = max(g[i-1][j], l[i][j]); &#125; &#125; return g[n-1][2]; &#125;&#125;; 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自Grandyang C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if (prices.empty()) return 0; int g[3] = &#123;0&#125;; int l[3] = &#123;0&#125;; for (int i = 0; i &lt; prices.size() - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; for (int j = 2; j &gt;= 1; --j) &#123; l[j] = max(g[j - 1] + diff, l[j] + diff); g[j] = max(l[j], g[j]); &#125; &#125; return g[2]; &#125;&#125;; 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。 Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。 C++ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 1||prices.empty() ||k == 0) &#123; return 0; &#125; if(k &gt;= prices.size()) &#123; return maxProfit_1(prices); &#125; int n = prices.size(); vector&lt;int&gt; g(k+1, 0); vector&lt;int&gt; l(k+1, 0); for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = k; j &gt;=1; --j) &#123; l[j] = max(g[j-1]+diff, l[j]+diff); g[j] = max(g[j], l[j]); &#125; &#125; return g[k]; &#125; int maxProfit_1(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int n = prices.size(); for(int i = 1; i &lt; n; ++i) &#123; if(prices[i] &gt;prices[i-1]) &#123; res += (prices[i] - prices[i-1]); &#125; &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock with CooldownSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考Grandyang的方法，维护三个数组buy[],sell[]和rest[]。 其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为： buy[i] = max(rest[i-1]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); rest[i] = max(buy[i-1], sell[i-1], rest[i-1]); 上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以 rest[i] = max(sell[i-1], rest[i-1]); 此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为 buy[i] = max(sell[i-2]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); 可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。 C++ 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0; for (int price : prices) &#123; pre_buy = buy; buy = max(pre_sell - price, pre_buy); pre_sell = sell; sell = max(pre_buy + price, pre_sell); &#125; return sell; &#125;&#125;; 以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。[Grandyang](http://www.cnblogs.com/grandyang/p/4281975.html)的博客给我提供了很大帮助。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
</search>
