<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <url>%2F2019%2F06%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式——单例模式单例模式的目的单例模式属于一种对象创建模式。用于确保软件系统中某些特殊的类只能有一个实例，这样才能保证逻辑上的正确性以及降低创建对象产生的成本。 单例模式的定义保证一个类只有一个实例，并提供一个该实例的全局访问点。 —— 《设计模式》GoF 单例模式的几种实现方法首先值得注意的是，确保某个类在系统中只有一个实例是类设计者的责任，而不是使用者的责任。 要实现单例模式，重要的一点是绕过常规的构造函数，创建一种只能被实例化一次的构造方式。实现单例模式有许多种方法，因为单例模式可以说是最简单的设计模式，要求也很少。但是实际上实现一个安全且完善的单例模式并不是一个简单的事情。主要需要考虑的是线程安全和创建时机。 实现一个单例模式，至少需要做到： 将类的构造函数设为私有函数 使用一个私有静态指针访问所创建的对象（懒汉模式）（静态指针确保对象的生命期和程序一样长） 使用一个静态函数调用私有的构造函数，创建一个单例对象（静态成员函数确保该函数不属于某个具体对象，只属于这个类） 对于一个单例模式来说，为了保证类对象的唯一性，不能有拷贝构造函数和拷贝赋值函数。可以用C++中的=delete关键字将拷贝构造函数和拷贝赋值函数设为空。 懒汉和饿汉单例模式按照初始化的时机分为懒汉模式和饿汉模式。懒汉模式即在第一次使用该对象时进行初始化，饿汉模式是在程序运行时立刻初始化。 懒汉模式1234567891011121314151617181920class Singleton&#123;private: Singleton(); Singleton(const Singleton&amp; other); //或=delete Singleton operator=(const Singleton&amp; other); //=deletepublic: static Singleton* getInstance();private: static Singleton* m_instance;&#125;;//线程非安全版本Singleton* Singleton::getInstance() &#123; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125;// init static memberSingleton* Singleton::instance = NULL;//在第一次使用时调用getInstance初始化一个Singleton对象指针。 饿汉模式1234567891011121314151617class Singleton&#123;private: static Singleton instance; //存储Singleton对象而不是指针作为私有成员，在程序开始时直接初始化该成员private: Singleton(); ~Singleton(); Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton&amp; getInstance() &#123; return instance; &#125;&#125;// initialize defaultlySingleton Singleton::instance; //该步骤在main函数之前执行，即程序开始时就初始化一个全局的静态Singleton对象。 线程安全的实现以上的懒汉模式和饿汉模式的具体实现都是有安全问题的。 首先说懒汉模式的安全问题。单例模式的复杂之处就是要考虑线程安全问题。如果是在单线程环境下，上面的懒汉模式实现没有任何问题，可以安全运行。但是如果在多线程环境下，就会产生race condition，如果多个线程同时执行到getInstance()的话就会生成多个Singleton对象。实现线程安全版本的懒汉模式有多种方法（以下代码只有getInstance函数）：12345678//线程安全版本，但锁的代价过高Singleton* Singleton::getInstance() &#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125; 最简单的线程安全方法就是直接加锁，用互斥锁保证线程安全。这样做确实是线程安全的，但是带来的副作用是每个线程都要先获取锁，然后检查是否已有Singleton对象，这样产生的代价过高。于是有了下面的双检查锁的想法1234567891011//双检查锁，但由于内存读写reorder不安全Singleton* Singleton::getInstance() &#123; if(m_instance==nullptr)&#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; &#125; return m_instance;&#125; 双检查锁的思路是先判断是否有Singleton对象，如果有就直接返回，不用获取锁，如果没有就获取锁，然后再次判断是否有Singleton对象（因为在获取锁时可能也有另外线程阻塞在锁处，如果没有第二次检查就会造成多个线程创建了Singleton对象），如果没有就创建一个。这样的思路提123456789101112131415161718192021222324251. 先调用malloc分配远程内存2. 调用对象的构造函数对内存进行构造3. 返回指向该内存的指针通常情况下，编译器在将源码编译为汇编时会按照上述的顺序执行汇编指令，但是在实际中，编译器有时会按照优化步骤执行，可能得到的结果是按照1,3,2顺序执行的，即先分配内存，然后返回指向该内存的指针，然后再调用构造函数。这样的顺序在单线程环境下也是没问题的，但是在多线程环境下，会产生这样的情况：构造该对象的线程按照1,3,2的顺序执行到new的3，此时没有对内存进行构造，但是m_instance已经有指向的内存，即m_instance是有值的，此时另一个线程执行到 if(m_instance==nullptr) 一句，看到m_instance非空，于是返回m_instance。如果此时第二个线程使用了m_instance所指向的内存就会得到错误的结果，因为此时m_instance指向的内存还没有被构造。这样的情况不仅在C++中存在，在Java和C#中也是存在的。相应的解决方法就是使用volatile关键字或C++中的atomic变量，来确保编译器不会执行上述的优化。```C++//C++ 11版本之后的跨平台实现 (volatile)std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance; // Singleton* tmp = m_instance.load(std::memory_order_relaxed); // std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); //tmp = m_instance.load(std::memory_order_relaxed); if ((tmp=m_instanct) == nullptr) &#123; m_instance = tmp = new Singleton; // std::atomic_thread_fence(std::memory_order_release);//释放内存fence // m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 上面代码使用了atomic关键字，m_instance的构造过程是原子的，不会产生其他线程读到脏数据的情况。同时返回一个非atomic指针tmp，主要是考虑atomic指针的性能损失。注释部分是在C++11之前的做法，设置一个内存屏障来保证内存中数据与cache中数据的一致性。 《Effective C++》中提出了一种优雅的单例模式实现方法：1234567891011121314class Singleton&#123;private: Singleton() &#123; &#125;; ~Singleton() &#123; &#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton&amp; getInstance() &#123; static Singleton instance; return instance; &#125;&#125;; 这种方法只能在C++11以后使用，因为C++11中规定了local static变量在多线程环境下的行为，要求编译器保证局部静态变量的线程安全性。所以上面代码中使用了 static Singleton instance; 在getInstance中创建Singleton对象，是安全的。 饿汉模式在main函数之前初始化Singleton对象，没有线程安全问题，“但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和static Singleton&amp; getInstance()二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。”（来源https://zhuanlan.zhihu.com/p/37469260）。 单例模式结构图 总结Singleton中的构造函数也可以设为protected而不是private，以方便派生类使用。此外要注意通常不能有拷贝构造和拷贝复制函数。最后要注意Singleton对象的创建时机和线程安全性，尤其是双检查机制是非线程安全的。要用atomic或volatile关键字确保线程安全。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂方法（Factory）]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[设计模式——工厂方法（Factory）工厂方法的目的工厂方法属于一种“对象创建”模式，通过工厂方法可以创造一种替换new方法的创建对象的方法，避免用new创建具体类对象，导致对象之间的紧耦合。从而支持对象创建的稳定。工厂模式解决的是这样的问题，由于生产过程中需要创建的对象类型是不固定的，通常是一系列有关系的对象都可能需要被创建，由于对象的具体类型可能发生变化，用new方法就达不到较高的灵活性，所以使用工厂方法，提供一种类似于new但是不指明具体类型的行的封装机制，来避免客户程序与所需具体类对象间的紧耦合。 工厂方法的定义定义一个用于创建对象的接口，让子类决定最终实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。 —— 《设计模式》GoF 工厂方法例程123456789101112131415161718192021class ISplitter&#123; //经过Strategy模式重构的结果，去除了多算法与对象之间的耦合性public: virtual void split()=0; virtual ~ISplitter()&#123;&#125;&#125;;class BinarySplitter : public ISplitter&#123; &#125;;class TxtSplitter: public ISplitter&#123; &#125;;class PictureSplitter: public ISplitter&#123; &#125;;class VideoSplitter: public ISplitter&#123; &#125;; 123456789101112131415161718class MainForm : public Form&#123; TextBox* txtFilePath; TextBox* txtFileNumber; ProgressBar* progressBar;public: void Button1_Click()&#123; ISplitter * splitter= new BinarySplitter();//依赖具体类 splitter-&gt;split(); &#125;&#125;; 以上是没有使用工厂方法的例程。这两个文件实现了一个文件分解器，其中分解器需要能支持不同类型的文件，如Binary，Txt，Picture，Video。在mainform中用new方法创建了具体要调用的特定文件类型的文件分解器。这样的话就造成了mainform与BinarySplitter的紧耦合，如果以后需求有变更，需要分解的是Picture文件或其他类型文件，那么就需要更改Mainform类的代码，而mainform应该是一段可复用的代码，这是我们不希望发生的。 可以通过工厂方法解耦和。123456789101112131415//抽象类class ISplitter&#123; //是对应具体文件分解器的抽象public: virtual void split()=0; virtual ~ISplitter()&#123;&#125;&#125;;//工厂基类class SplitterFactory&#123; //是生产对应文件分解器的工厂的抽象public: virtual ISplitter* CreateSplitter()=0; virtual ~SplitterFactory()&#123;&#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//具体类class BinarySplitter : public ISplitter&#123; &#125;;class TxtSplitter: public ISplitter&#123; &#125;;class PictureSplitter: public ISplitter&#123; &#125;;class VideoSplitter: public ISplitter&#123; &#125;;//具体工厂class BinarySplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new BinarySplitter(); &#125;&#125;;class TxtSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new TxtSplitter(); &#125;&#125;;class PictureSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new PictureSplitter(); &#125;&#125;;class VideoSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new VideoSplitter(); &#125;&#125;; 123456789101112131415161718192021//用抽象的工厂的指针指向具体工厂，用具体工厂生产具体的分解器对象class MainForm : public Form&#123; SplitterFactory* factory;//工厂public: MainForm(SplitterFactory* factory)&#123; this-&gt;factory=factory; &#125; void Button1_Click()&#123; ISplitter * splitter= factory-&gt;CreateSplitter(); //多态new splitter-&gt;split(); &#125;&#125;; 在上面的例程中，使用了工厂模式进行重构。首先抽象出各个类型分解器的抽象基类，ISplitter，以及工厂的抽象基类，SplitterFactory，由SplitterFactory生产（返回）ISplitter对象的指针，即通过工厂创建了ISplitter对象。然后，由各种具体分解器的类继承ISplitter，实现具体功能，由各种具体类型分解器的工厂继承SplitterFactory，具体生产各种Splitter。在mainform中维护一个SplitterFactory的成员，由调用mainform的客户程序传递具体工厂类型给mainform，用于初始化SplitterFactory，在mainform类对象中创建相应的Splitter。如果需要改变创建对象的具体类型只要传递不同的工厂类型指针即可，添加新的类型也只需要写新的子类即可，对已有代码不造成任何影响。所以，实际上的创建对象的类型是在运行时绑定的，像其他设计模式一样，也是使用虚函数的动态绑定机制，实现了多态性。将创建对象的具体类型延迟到运行时决定，这样的做法使底层代码复用性更强，不依赖于具体的对象，耦合性低。 工厂模式的结构图 工厂模式总结Factory Method实际上完成了类对象使用者与类对象之间的解耦和，在具体对象类型可能发生变化的情境中，用new方法导致的紧耦合会是程序不稳定。 Factory Method通过面向对象的方法，将创建具体对象的工作延迟到子类中，在运行时动态绑定，从而实现了一种可扩展（而不是更改）的策略。 Factory Method解决的是“单个对象”的需求变化。缺点在与要求所创建方法和参数是相同的，即可变的类型是一系列相关的类型。这其实是工厂模式中要求稳定的部分，并不算是真正的缺点。所有设计模式都要求有稳定的部分和可变的部分，某种程度上讲，稳定的部分就是设计模式的弱点。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——抽象工厂方法（Abstract Factory）]]></title>
    <url>%2F2019%2F06%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式——抽象工厂方法（Abstract Factory）抽象工厂的目的抽象工厂模式其实是在工厂模式基础上实现的。它与工厂模式不同的地方在于，工厂模式解决的是单个对象的类型是变化的情况，抽象工厂模式解决的是一系列相互关联的对象共同变化的情况。所以需要比工厂模式多一层抽象，将一系列相互关联的对象封装起来。这就是抽象工厂模式。 抽象工厂模式定义提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。 —— 《设计模式》GoF 抽象工厂模式例程没有使用工厂模式的例程123456789101112131415161718class EmployeeDAO&#123;public: vector&lt;EmployeeDO&gt; GetEmployees()&#123; SqlConnection* connection = new SqlConnection(); connection-&gt;ConnectionString = "..."; SqlCommand* command = new SqlCommand(); command-&gt;CommandText="..."; command-&gt;SetConnection(connection); SqlDataReader* reader = command-&gt;ExecuteReader(); while (reader-&gt;Read())&#123; &#125; &#125;&#125;; 这个例程是使用数据库的三个功能的程序，其中数据库类型是会变化的，但是每种数据库都有对应的三个功能，connection，command和reader。也就是说随着数据库的类型不同，这三个对象的类型也是一同变化的。在没有使用Factory Method的时候，用new方法创建对象造成了紧耦合，需要解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//使用工厂模式//数据库访问有关的基类class IDBConnection&#123; &#125;;class IDBConnectionFactory&#123;public: virtual IDBConnection* CreateDBConnection()=0;&#125;;class IDBCommand&#123; &#125;;class IDBCommandFactory&#123;public: virtual IDBCommand* CreateDBCommand()=0;&#125;;class IDataReader&#123; &#125;;class IDataReaderFactory&#123;public: virtual IDataReader* CreateDataReader()=0;&#125;;//支持SQL Serverclass SqlConnection: public IDBConnection&#123; &#125;;class SqlConnectionFactory:public IDBConnectionFactory&#123; &#125;;class SqlCommand: public IDBCommand&#123; &#125;;class SqlCommandFactory:public IDBCommandFactory&#123; &#125;;class SqlDataReader: public IDataReader&#123; &#125;;class SqlDataReaderFactory:public IDataReaderFactory&#123; &#125;;//支持Oracleclass OracleConnection: public IDBConnection&#123; &#125;;class OracleCommand: public IDBCommand&#123; &#125;;class OracleDataReader: public IDataReader&#123; &#125;;class EmployeeDAO&#123; IDBConnectionFactory* dbConnectionFactory; IDBCommandFactory* dbCommandFactory; IDataReaderFactory* dataReaderFactory; public: vector&lt;EmployeeDO&gt; GetEmployees()&#123; IDBConnection* connection = dbConnectionFactory-&gt;CreateDBConnection(); connection-&gt;ConnectionString("..."); IDBCommand* command = dbCommandFactory-&gt;CreateDBCommand(); command-&gt;CommandText("..."); command-&gt;SetConnection(connection); //关联性 IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性 while (reader-&gt;Read())&#123; &#125; &#125;&#125;; 这段例程使用了工厂模式，将三个对象用各自的工厂生产出来，与客户程序解耦和。但是这里存在一个问题，就是IDBConnection，IDBCommand和IDataReader应该是一同变化的，而在上面的实现中没有做到这一点，需要程序员来保持三个对象的一致性，这是有潜在危险的。所有通过抽象工厂模式进一步抽象，将三个对象封装起来。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//数据库访问有关的基类class IDBConnection&#123; &#125;;class IDBCommand&#123; &#125;;class IDataReader&#123; &#125;;class IDBFactory&#123;public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; &#125;;//支持SQL Serverclass SqlConnection: public IDBConnection&#123; &#125;;class SqlCommand: public IDBCommand&#123; &#125;;class SqlDataReader: public IDataReader&#123; &#125;;class SqlDBFactory:public IDBFactory&#123;public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; &#125;;//支持Oracleclass OracleConnection: public IDBConnection&#123; &#125;;class OracleCommand: public IDBCommand&#123; &#125;;class OracleDataReader: public IDataReader&#123; &#125;;class EmployeeDAO&#123; IDBFactory* dbFactory; public: vector&lt;EmployeeDO&gt; GetEmployees()&#123; IDBConnection* connection = dbFactory-&gt;CreateDBConnection(); connection-&gt;ConnectionString("..."); IDBCommand* command = dbFactory-&gt;CreateDBCommand(); command-&gt;CommandText("..."); command-&gt;SetConnection(connection); //关联性 IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性 while (reader-&gt;Read())&#123; &#125; &#125;&#125;; 上面例程使用了抽象工厂模式，用IDBFactory类封装了IDBConnection，IDBCommand和IDataReader三个对象，在EmployeeDAO中使用IDBFactory类型指针管理三个对象。确保它们之间的一致性。这就是抽象工厂模式的使用。 抽象工厂模式结构图 抽象工厂模式总结Abstract Factory解决的问题是“多系列对象构建”的需求变化问题，可以认为是工厂模式的一般情况。并且要求这一系列对象之间是有关或相互依赖的，需要一致变化，这样使用抽象工厂模式才有意义。 工厂模式应对的是新对象的需求变动，抽象工厂模式应对的是新系列对象的需求变动。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[设计模式——模板方法模板方法的目的在软件设计时，通常对于某类任务有相对固定的处理框架，而框架中的各个子任务有着不同的处理方式（函数），或者子任务的需求预计会变化的，或者框架与子步骤无法同时实现，框架要先与子步骤实现。在这样的情境下，可以使用模板方法来确保操作结构的稳定，并应对可能有变化的子步骤。 模板方法的实现模板方法实际上就是使用虚函数机制实现晚绑定的方法。 在不使用模板方法的时候，软件的结构可能需要写成一个类库，由类库的使用者调用库中的函数，或者生成一个已经写好了结构的文件，由使用者填充需要自己实现的函数。这种情况称为早绑定方法，同时也是面向过程的方法，即在软件编写时就确定需要使用的子步骤函数，填充到框架中。这样的方法是由使用者调用框架的函数，增加了使用者的使用成本。而使用模板方法使得类的使用者只关注自己的函数即可。 非模板方法12345678910111213141516//程序库开发人员class Library&#123;public: void Step1()&#123; //... &#125; void Step3()&#123; //... &#125; void Step5()&#123; //... &#125;&#125;; 123456789101112131415161718192021222324252627282930//应用程序开发人员class Application&#123;public: bool Step2()&#123; //... &#125; void Step4()&#123; //... &#125;&#125;;int main()&#123; Library lib(); Application app(); lib.Step1(); if (app.Step2())&#123; lib.Step3(); &#125; for (int i = 0; i &lt; 4; i++)&#123; app.Step4(); &#125; lib.Step5();&#125; 如上例所示，不采用模板方法编写的软件框架需要在调用框架内的函数之前对框架有所了解，每次编写使用该框架的程序都需要重写编写框架的部分，而框架部分应该是可以复用的，所以使用模板方法，将框架部分实现为一个可复用的软件骨架，用虚函数机制在对应的子类中override框架中动态变化的部分。 模板方法123456789101112131415161718192021222324252627282930313233343536//程序库开发人员class Library&#123;public: //稳定 template method void Run()&#123; Step1(); if (Step2()) &#123; //支持变化 ==&gt; 虚函数的多态调用 Step3(); &#125; for (int i = 0; i &lt; 4; i++)&#123; Step4(); //支持变化 ==&gt; 虚函数的多态调用 &#125; Step5(); &#125; virtual ~Library()&#123; &#125;protected: void Step1() &#123; //稳定 //..... &#125; void Step3() &#123;//稳定 //..... &#125; void Step5() &#123; //稳定 //..... &#125; virtual bool Step2() = 0;//变化 virtual void Step4() =0; //变化&#125;; 12345678910111213141516171819202122//应用程序开发人员class Application : public Library &#123;protected: virtual bool Step2()&#123; //... 子步骤的实现 &#125; virtual void Step4() &#123; //... 子步骤的实现 &#125;&#125;;int main()&#123; Library* pLib=new Application(); lib-&gt;Run(); delete pLib;&#125; 可以看见，使用模板方法之后只需要类的使用者完成自己的子函数，子函数会被软件框架所调用，而不是由类的使用者去调用框架中的函数，更不需要自己写一遍软件的流程。这样实现了稳定部分的复用，以及动态部分的变化。 总结Template Method方法利用虚函数机制实现了程序框架的灵活扩展，实现了框架代码的复用。晚绑定方法是template method的典型特征。在具体实现上，可以将template method调用的虚函数设计为有具体实现的，也可以是纯虚函数，一般推荐设置为protected。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式（Strategy）]]></title>
    <url>%2F2019%2F06%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式——策略模式（Strategy）策略模式的目的在软件构建过程中，某些对象所使用的算法和面对的情境可能随时发生改变或扩展，如果将所需的算法静态地绑定到类中，那么后面发生更改时所有这个类的对象都要发生变化，对象的构造也会非常复杂。因此需要构造一个能够在运行时根据需要动态绑定相应算法的类，将算法与对象本身解耦；策略模式就是这样的方法。 策略模式的定义定义一系列算法，把他们一个个封装起来，并且使他们可以互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。——《设计模式》GoF 使用策略模式的例子未使用策略模式的情况123456789101112131415161718192021222324252627282930enum TaxBase &#123; CN_Tax, US_Tax, DE_Tax, FR_Tax //更改&#125;;class SalesOrder&#123; TaxBase tax;public: double CalculateTax()&#123; //... if (tax == CN_Tax)&#123; //CN*********** &#125; else if (tax == US_Tax)&#123; //US*********** &#125; else if (tax == DE_Tax)&#123; //DE*********** &#125; else if (tax == FR_Tax)&#123; //更改 //... &#125; //.... &#125; &#125;; 在没有使用策略模式且面临一个对象可能使用多个算法的情况，常常需要在对象中实现多个算法，用if……else……的语句连接起来。遇到需要更改或者添加新的算法的时候，则需要更改原有的类。这样的类设计使得算法与类本身耦合度变高，使对象变得复杂。同时，支持不需要的算法也是一种浪费。 使用策略模式的情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)=0; virtual ~TaxStrategy()&#123;&#125;&#125;;class CNTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;class USTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;class DETax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;//扩展//*********************************class FRTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //......... &#125;&#125;;class SalesOrder&#123;private: TaxStrategy* strategy;public: SalesOrder(StrategyFactory* strategyFactory)&#123; this-&gt;strategy = strategyFactory-&gt;NewStrategy(); &#125; ~SalesOrder()&#123; delete this-&gt;strategy; &#125;public: double CalculateTax()&#123; //... Context context(); double val = strategy-&gt;Calculate(context); //多态调用 //... &#125; &#125;; 在使用策略模式的代码中，首先用一个抽象基类TaxStrategy来将表示税收的算法抽象出来，具体的某个国家或某种计税方法来继承抽象基类，在派生类中实现具体的算法。然后在使用时用基类的指针的多态性，实现动态绑定，运行时调用不同的派生类对象的函数。这种方法的可扩展性强，只要多写一个派生类override基类中的虚函数就可以了。更改的时候也只需要更改对应的派生类，影响范围小，复杂性低。 策略模式实际上还是利用虚函数的动态绑定机制，实现晚绑定，在运行时与调用对应算法，实现算法与类对象的松耦合。 策略模式结构图 策略模式总结Strategy方法使用虚函数的晚绑定机制提供了一系列可重用的算法，用基类指针使得在运行时可以方便地根据需要在各个算法之间切换。并且经常可以用Strategy模式对连续的if……else……形式的语句进行重构，这意味着出现过多的if……else……应该考虑用Strategy模式来解耦合。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——观察者模式（Observe）]]></title>
    <url>%2F2019%2F06%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式——观察者模式（Observe）观察者模式的目的在软件构建的过程中，有时需要建立一种“通知依赖关系”，一个对象的状态发生变化，所有依赖该对象的对象都会收到通知。如果这样的依赖关系太紧密，将使软件不能很好的抵御变化。使用观察者模式，可以弱化依赖关系，并使这种依赖关系稳定，实现结构的松耦合。 观察者模式的定义定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 ——《设计模式》GoF 观察者模式代码没使用观察者模式的情况12345678910111213141516171819202122232425262728class FileSplitter&#123; string m_filePath; int m_fileNumber; ProgressBar* m_progressBar;public: FileSplitter(const string&amp; filePath, int fileNumber, ProgressBar* progressBar) : m_filePath(filePath), m_fileNumber(fileNumber), m_progressBar(progressBar)&#123; &#125; void split()&#123; //1.读取大文件 //2.分批次向小文件中写入 for (int i = 0; i &lt; m_fileNumber; i++)&#123; //... float progressValue = m_fileNumber; progressValue = (i + 1) / progressValue; m_progressBar-&gt;setValue(progressValue); &#125; &#125;&#125;; 123456789101112131415161718class MainForm : public Form&#123; TextBox* txtFilePath; TextBox* txtFileNumber; ProgressBar* progressBar;public: void Button1_Click()&#123; string filePath = txtFilePath-&gt;getText(); int number = atoi(txtFileNumber-&gt;getText().c_str()); FileSplitter splitter(filePath, number, progressBar); splitter.split(); &#125;&#125;; 上面两段代码实现的是将大文件分解为小文件，同时将分解的进度用进度条表示。其中ProgressBar*指向的对象就是依赖FileSplitter的，FileSplitter将分解的进度写入ProgressBar当中。这样的实现静态来看没有什么问题，但是实际上将一个具体类对象用组合的方式放入依赖的对象中，限制了观察者的数量，如果有其他类型的检测进度的类对象就需要在FileSplitter类中添加新的类对象指针，这样会增加类的复杂度和类之间的耦合性。为了解决这个问题，可以将观察者抽象出来作为一个基类，将基类的对象注册到所依赖的类对象中，然后具体的进度表达方式在派生类中完成。这样就实现了类之间一对多的依赖关系，降低了类之间的耦合性。 使用了观察者模式的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class IProgress&#123;public: virtual void DoProgress(float value)=0; virtual ~IProgress()&#123;&#125;&#125;;class FileSplitter&#123; string m_filePath; int m_fileNumber; List&lt;IProgress*&gt; m_iprogressList; // 抽象通知机制，支持多个观察者 public: FileSplitter(const string&amp; filePath, int fileNumber) : m_filePath(filePath), m_fileNumber(fileNumber)&#123; &#125; void split()&#123; //1.读取大文件 //2.分批次向小文件中写入 for (int i = 0; i &lt; m_fileNumber; i++)&#123; //... float progressValue = m_fileNumber; progressValue = (i + 1) / progressValue; onProgress(progressValue);//发送通知 &#125; &#125; void addIProgress(IProgress* iprogress)&#123; m_iprogressList.push_back(iprogress); &#125; void removeIProgress(IProgress* iprogress)&#123; m_iprogressList.remove(iprogress); &#125;protected: virtual void onProgress(float value)&#123; List&lt;IProgress*&gt;::iterator itor=m_iprogressList.begin(); while (itor != m_iprogressList.end() ) &#123; (*itor)-&gt;DoProgress(value); //更新进度条 itor++; &#125; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637class MainForm : public Form, public IProgress&#123; TextBox* txtFilePath; TextBox* txtFileNumber; ProgressBar* progressBar;public: void Button1_Click()&#123; string filePath = txtFilePath-&gt;getText(); int number = atoi(txtFileNumber-&gt;getText().c_str()); ConsoleNotifier cn; //一个观察者 FileSplitter splitter(filePath, number); splitter.addIProgress(this); //订阅通知 splitter.addIProgress(&amp;cn)； //订阅通知 splitter.split(); splitter.removeIProgress(this); &#125; virtual void DoProgress(float value)&#123; progressBar-&gt;setValue(value); &#125;&#125;;class ConsoleNotifier : public IProgress &#123; //一个观察者的实现public: virtual void DoProgress(float value)&#123; cout &lt;&lt; "."; &#125;&#125;; 在使用了观察者模式的代码中，将观察者的共同功能抽象成了一个抽象基类IProgress，其他具体的观察者继承IProgress，override其中的DoProgress函数，完成自己对进度的表达方式。在被依赖的对象FileSplitter中维护一个list，存储所有依赖自己的IProgress类对象，当自己的状态发生变化时就调用list中的对象的函数通知依赖自己的对象。并实现了注册观察者的函数和注销观察者的函数。观察者模式实现了方便的扩展观察者数量而不需要对所依赖的对象有所改动，即降低了依赖关系的强度，减小了耦合性。同样，这里使用的也是虚函数的动态绑定机制完成的。 观察者模式的结构 总结使用观察者模式，可以使依赖和被依赖对象之间相互独立地更改，扩展和添加，降低了依赖程度。 目标在发送通知时无需指定对应观察者，消息自动传播给所有观察者。 观察者的订阅情况目标不需要知道。实际上，Observe模式是也叫Event模式，是基于UI时间的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU密集和IO密集情况下的线程分配]]></title>
    <url>%2F2019%2F06%2F15%2FCPU%E5%AF%86%E9%9B%86%E5%92%8CIO%E5%AF%86%E9%9B%86%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[CPU密集和IO密集情况下的线程分配 CPU密集型任务 CPU密集型任务指的是CPU相对于磁盘、内存等存储设备的IO操作占用时间更长，性能更差的任务。在这样的场景下，时间主要消耗在CPU的计算中，如计算圆周率，解数独，解码视频等，IO在很短时间内就能完成,但是CPU常常处于满负荷状态。 IO密集型任务 IO密集型任务指的是磁盘、内存相对于CPU来说性能更差，IO时间占比更长的任务。在这样的场景下，时间主要消耗在对磁盘和内存的IO操作上，而这段时间CPU通常是空闲的，所以为了充分利用CPU的资源，需要比CPU密集型的任务多分配一些线程，以实现在某个线程执行IO时，调用其他线程调度空闲CPU线程执行新的任务。 并发程度对线程分配的影响 低并发 在低并发且执行时间短的情况下，可以分配和CPU核数相等的线程数量，以减少线程之间的切换所浪费的时间，这是对服务器压力最小的一种情况； 在低并发且执行时间长的情况下，需要按照IO密集还是CPU密集型任务合理分配线程数目。 高并发 在高并发且任务执行时间短的情况下，可以分配和CPU核数相等的线程数量或者CPU核数+1的线程，减少线程间的切换。在并发程度和执行时间都很长的情况下，不能单从线程分配的角度来解决问题，需要整体考虑架构的设计。首先需要考虑数据能够做缓存，如redis。其次考虑scale out，增加服务器的方式抵消高并发带来的影响。线程设置的部分还是要考虑IO密集和CPU密集的区别。同时，如果是IO密集型的操作，还应该考虑磁盘读写带来的IO吞吐量的瓶颈，通常IO密集操作中网络状态和缓存的性能都是强于磁盘的，可以从磁盘的角度优化IO操作，如磁盘空间预分配等。 线程分配的依据 陈硕在muduo库的介绍中提到了线程池大小的阻抗匹配原则。即在线程池执行任务时，如果密集计算的时间占比为P(0&lt;P&lt;=1)，CPU共有C个核，那么匹配的线程数目就是T=C/P，考虑P的计算可能不精确，T的值上下浮动50%左右。实际上这个公式的意思就是每个任务的占用CPU的时间乘以分配的线程数目大概相当于CPU的核数，即在CPU不过载的情况下尽量满载。接下来举例验证一下这个原则。 假设C=8，P=1.0，意味着这是一个CPU密集型的操作，CPU计算时间几乎占满，以至于IO的时间可以忽略不计。这样的话合理的线程数量T就是T=C/P=8.0，分配的线程数量与CPU核数一致，即使分配更多的线程也没有用，因为CPU的每个核都在执行计算任务，没有多余的资源供线程使用，不能提高效率，并且多分配了线程反而会因为线程间切换次数过多而降低效率。这也与前面的CPU密集型任务的理解一致。 当P&lt;0.2时，就不宜用公式计算线程数目了，T可以取一个固定的值。因为如果创建的线程数量过多，新的线程需要排队等待前面的线程执行结束后才能执行，并且会造成再次切换到当前线程所需的时间也会过长。而且当CPU计算较少时，频繁的IO事件唤醒线程也会过多消耗系统资源，所以线程池中线程数量不是越多越好，否则就像没有使用线程池而频繁创建和销毁线程一样，会在等待其它线程执行和被唤醒消耗系统资源方面降低整体效率。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struct中的对齐问题]]></title>
    <url>%2F2019%2F06%2F14%2Fstruct%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Struct中的对齐问题 什么是对齐 首先，对齐的意义在于提高CPU读取内存的效率，通常是编译器的工作，但是因为c语言对内存的操作比较强大，也可以使用#pragma pack(n)的方式设置对齐的尺寸。 具体来说，假设CPU是32位的，那么一个CPU字长是32bit，相当于对于CPU来讲，内存的最小存储单元就是32bit，也就是说CPU每次读取一个字的字长，不多也不少。通常假设在CPU运算中逻辑地址的最低为0（具体原因知乎有解答https://www.zhihu.com/question/27862634） 那么假如要访问地址为1的4个字节长度的数据（即[1,4]）时，32位CPU需要先访问[0,3]字节的数据，此时还有1字节没有访问到，需要再读取一遍内存，共读取两次。这种是未对齐的访问方式，即地址1mod大小4=1而不等于0，所以需要两次访问。假如这个数据从地址0开始，那么就可以在一次访问中就读取到完成数据，提高了效率。也就是说将数据向左移1个字节即可，地址0mod大小4=0，是对齐的情况。 所以，内存的对齐就是将数据按照一定规则安置在合适的内存空间中，使CPU访问次数尽量少，提高访问效率的一项工作。 如何对齐 对齐的规则需要分为数据成员的对齐方法和结构体整体的对齐两种，其实两种对齐方式的原则是一样的，结构体整体对齐方式也就是将结构体看做数据成员的情况下的数据成员的对齐方式。 具体来说，数据成员的对齐原则就是——大小为size的字段，它的结构内偏移offset需要符合offset mod size = 0。 这条原则是为了保证不同字长的CPU有兼容一致的模型，方便交换分析。按照上面原则对齐的结构体中的数据成员，每一个数据成员前面的地址偏移量对当前数据取模都是0，这样对齐后对与不同字长的CPU来讲读取的情况都是高效率的。可以实例验证一下。 那么结构体内的数据成员对齐之后，结构体间就对齐了吗？考虑如下情况： 123456struct hi &#123; let:4 //padding 4 us: 8 //padding 0 play: 1 //padding 1 together: 2 //padding ?&#125; (例子来源知乎https://www.zhihu.com/question/27862634) 考虑最后一个padding应给为几个字节？按照数据成员的对齐规则已经不用考虑together后面的padding了，因为后面没有数据成员了。这样的话？处为0，hi的size为20个字节。但是如果出现 1hi group[2]; 的使用方法的时候，由于第一个hi对象的size为20字节[0,19]，第二个hi对象的起始地址为20，此时第二个hi对象所面临的情况是：let[20,23](offset(20)mod size(4) == 0,已对齐),padding(let)[24,27]，us[28,36](offset(28) mod size(8) == 4,未对齐) 也就是说由于第一个hi对象中的最后一个数据成员没有padding，导致第二个对象中的us成员的起始位置是未对齐的。为了纠正这个问题，需要对结构体整体进行对齐，也就是对最后一个数据成员后面合理padding。 原则是，整个结构体的size必须是其最大数据成员size的整数倍。 这样，在hi中，最后一个padding应为4，即一个hi对象实际占用空间为24字节，就实现了结构体之间的对齐。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的虚函数]]></title>
    <url>%2F2019%2F04%2F06%2FC-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++中的虚函数为什么需要虚函数虚函数是用来实现C++的多态特性的。多态性主要体现在用相同的代码来表达不同的算法或函数，具体在虚函数机制中的实现，是通过由派生类重新定义并覆盖基类中的虚函数，来实现与基类不同的函数功能，并且不同的派生类之间相同虚函数的功能也可以不同，也就是多态、多种形态。由此机制产生的基类指针可以指向派生类的对象，调用与本身静态类型不同的对象的函数，从指针的角度来说，实现了相同的基类指针可以有多种形态。陈皓在博客中介绍这属于泛型技术，与模板技术，RTTI技术有相似的特点。 虚函数的用法虚函数的示例 1234567891011121314151617181920212223242526272829class Base&#123;public: Base() = default; Base(string input) :name_b(input)&#123;&#125;; virtual ~Base() = default; //通常含有虚函数的基类都应该定义一个虚析构函数。因为虚函数是在运行期间动态绑定的，基类指针可能指向派生类的对象，这样就可能引发析构函数不对应的问题，即需要析构派生类对象时调用了基类的析构函数。所以需要定义一个虚析构函数，虚析构函数与虚函数一样都是动态绑定的，因此在delete时能够保证调用正确的析构函数。虚析构函数不符合“三五法则”，即使需要定义虚析构函数，但是不需要定义拷贝构造函数和拷贝赋值函数，它是一个特例，由动态绑定机制产生的特例。 virtual void foo_1() &#123; cout &lt;&lt; "This is foo_1 in Base" &lt;&lt; endl; &#125;; virtual void foo_2() &#123; cout &lt;&lt; "This is foo_2 in Base" &lt;&lt; endl; &#125;;private: string name_b;&#125;;class Derived:public Base&#123;public: Derived() = default; Derived(string input):name_d(input)&#123;&#125;; void foo_1() final &#123; //final表示不允许这个虚函数在派生类中再被覆盖 cout &lt;&lt; "This is foo_1 in derived" &lt;&lt; endl; &#125; void foo_2() override; //override表示覆盖基类版本,用override的好处在于可以避免发生函数名称或参数数量的错误。如果没有override，假如在派生类中定义的函数与基类中有相同名称但是类型或参数不同，会被编译器认为是函数的重载，而不会覆盖基类中的同名虚函数，但这种情况通常是程序员本意想要覆盖虚函数但犯了错误，这种错误很难查出。如果使用override关键字，则编译器会发现派生类中要进行覆盖的函数与基类中的虚函数不同，因此不会执行覆盖的操作，而是会报错。private: string name_d;&#125;; C++多态性实现的关键，是基类指针指向的对象可能与自身的静态类型不符，派生类对象的指针和引用可以向基类的指针和引用进行类型转换。但是需要注意的是，对象本身之间不存在类型转换，该操作仅限于指针和引用。 虚函数的动态绑定当我们使用含有虚函数的基类时，需要对所有的虚函数进行定义。因为虚函数是在运行期间才确定调用哪个版本，在访问到相应的内存后才知道是调用这个虚函数，所以编译器在编译时并不知道具体使用的是哪个虚函数，所以必须对所有虚函数进行定义，防止访问到未定义的函数，即使不会用到的虚函数也要有定义。虚函数有传递性，基类中定义的虚函数在派生类中被覆盖后依然是虚函数，仍然可以被派生类的派生类继续覆盖。除非使用final关键字禁止该虚函数被覆盖。 回避虚函数机制有时我们需要使用指向派生类的基类指针调用基类的虚函数而不是派生类的虚函数，这时就需要回避虚函数机制。做法很简单，使用作用域运算符就可以实现。 1234Base *b;b = new Drive();b-&gt;foo_1(); //调用的是派生类的虚函数b-&gt;Base::foo_1(); //调用的是基类的虚函数 C++primer中提到，在使用回避虚函数机制时要注意一点：如果派生类中的虚函数需要调用它的基类版本，但是在编程时忘记使用作用域运算符，就会导致该派生类虚函数无限调用自身，陷入死循环。所以在使用虚函数回避机制时，要十分明确调用哪个版本的虚函数。 纯虚函数与抽象基类纯虚函数的作用在于声明一个具有一般性的、没有具体含义的函数，通常用来表示一个通用的、抽象的概念，这个函数的只能由它的派生类覆盖来赋予具体的算法和含义。含有未被覆盖的纯虚函数的基类叫做抽象基类，抽象基类不能实例化一个对象，因为纯虚函数没有定义也没有具体含义。 使用纯虚函数时只要在声明时加上=0即可； 12345678class Abstract&#123;public: Abstract() = default; virtual ~Abstract() = default; void pure_v () const = 0; //纯虚函数 ……&#125; 纯虚函数也可以拥有定义，但是不能在类的内部定义，只能写在外部；不能创建抽象基类的对象，即使纯虚函数有类外定义也不行。 虚函数表关于虚函数表的内容，我觉得陈皓的博客讲的非常好，C++虚函数表解析。这篇博客中关于类对象的首地址描述似乎有些问题，根据实验，类对象的首地址确实是虚函数表的地址，但是对象的首地址与第一个虚函数的地址并不一致，实际上虚函数表并不存储在类对象的数据区域中，而是在对象的数据区存储指向虚函数表的虚表指针，因此类对象的首地址与第一个虚函数的首地址并不相同，这里容易出现误解。关于C++对象的存储模型可以参考博客C++类的存储方式及虚函数表。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议中链接的建立与断开]]></title>
    <url>%2F2019%2F03%2F29%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%2F</url>
    <content type="text"><![CDATA[TCP协议中链接的建立与断开根据TCP协议，运输连接有三个阶段：连接的建立，数据传输和连接的释放。其中数据的传输部分主要又停止等待协议，流量控制和拥塞控制等主要内容，保证数据的可靠到达和网络的性能。连接的建立和释放同样有完整的过程，确保连接建立和释放的正确。 TCP协议中链接的建立TCP采用的是client和server的模型，发起连接的一方是client，接受连接的一方是server。连接的成功建立要经历三次握手。三次握手的主要目的就是初始化报文序号seq，并通知对方自己的初始sequence number。 第一次握手：在建立连接之前，server端需要先创建传输控制块TCB，是服务器的进程进入listen状态，准备好接受client发来的连接请求；client同样创建TCB，然后向server发送连接请求报文段，SYN报文段。SYN报文段中，SYN标志位被设为1，并选择一个 初始序号seq=x。SYN报文段不能携带数据但是要占用一个序号。发送SYN报文段之后，client进入SYN-SENT（同步已发送）状态 第二次握手：server端接收到连接请求后，如果同意建立连接，就发送一个确认报文。在确认报文段中，ACK和SYN都置为1，确认号是初始序号加1，即x+1，确认报文的序号是server自己选择的初始序号。确认报文段也占一个序号并且不能携带数据。发送确认报文段后，server进入SYN-RCVD（同步收到）状态 第三次握手：client在收到server的确认报文之后，还要对该确认报文进行确认，client向server发送一个确认报文，该报文中ACK标识位置为1，序号是x+1，确认序号是y+1。该确认报文可以携带数据，也可以不携带。如果不携带数据就不消耗序号。client发送出确认报文之后连接已经建立，client进入ESTABLISHED状态；server收到client的确认报文之后，也进入ESTABLISHED状态，连接建立 第三次握手的原因client对server的确认报文进行确认的主要原因是防止已经失效的连接请求意外地到达server端。已失效的连接请求的产生原因可能是，client先发送了一个连接请求，但是在网络中某处延迟了，然后client重新发送连接请求，第二次的连接请求成功与server建立连接，然后在该连接断开后，第一个连接请求到达了server，导致server误认为client又发送了一次连接请求。如果没有第三次握手的机制，server就会单方面建立连接，等待client发来数据，导致资源浪费。因此，第三次握手是有必要的。 TCP协议中连接的释放断开连接过程中的四次挥手实际上是两次，因为TCP连接是全双工的，断开过程中client和server都需要发送FIN以及接收对方对FIN的确认，所以client发送FIN，server接收并确认，server发送FIN，client接收并确认，是一个对称的过程。client和server都可以主动断开连接。 假设client主动断开连接： 第一次挥手： 此时client处于ESTABLISHED状态，client发送终止连接的报文，将FIN置为1，设序号seq=u。此时client进入FIN-WAIT-1状态。FIN报文段不携带数据但是要消耗一个序号 第二次挥手： server收到client发来的FIN报文段后发送确认报文，将ACK置为1，确认号ack=u+1，随后进入CLOSE-WAIT状态。client在收到ACK后进入FIN-WAIT-2状态。此时TCP连接处于半关闭状态，如果server有数据要发送的话，client还是会接收，但是client不会再向server发送数据了 第三次挥手： server如果没有要发送的数据，就向client发送FIN报文段，将FIN置为1，ACK置为1，并重复上一次发送过的确认号ack=u+1。发送后，server进入LAST-ACK状态 第四次挥手： client在收到server的FIN报文段后，需要进行确认，发送确认报文段，将ACK置为1，确认号是收到的FIN序号加1.发送后进入TIME-WAIT阶段。server在收到确认后进入CLOSE状态。client的TIME-WAIT状态会持续2MSL（最长报文段寿命），由时间等待计时器计时。 TIME-WAIT状态的作用 保证自己的确认报文段能被对方成功接收。假如没有TIME-WAIT，而是直接断开连接，那么如果确认报文在网络中丢失或延迟，导致对方没有收到，对方会重新发送FIN报文，此时连接已断开，无法收到对方重发的FIN报文段，对方就无法按步骤进入CLOSED状态 防止前面提到的已失效连接请求出现在本次连接中。这与连接建立的第三次握手起的作用一样，相当于双重保障。因为经过2MSL后，主动断开连接的一方发送的所有报文完全在网络中消失，确保之前发的连接请求也消失。 因为被动方在收到ACK报文后立即进入CLOSED状态，因此被动方比主动方早进入CLOSED状态。 保活计时器TCP连接会维护一个保活计时器，防止对方因为突发情况，没有按照正常的断开流程断开连接。通常server会在每次收到client的报文后重置保活计时器，一般等待时间是2小时。如果2小时内没有收到client的报文，则发送一个探测报文段，此后每隔75分钟发送一次，如果连续10个探测报文段都没有收到回应，则断开连接。]]></content>
      <categories>
        <category>C++服务器</category>
      </categories>
      <tags>
        <tag>Network programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议中的拥塞控制]]></title>
    <url>%2F2019%2F03%2F29%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[TCP协议中的拥塞控制为什么要进行拥塞控制在网络中，如果各个主机请求的资源超过了网络能够承载的负荷，则发生拥塞，网络的性能会变坏。发生拥塞的原因有很多，并不能通过简单地增加节点内存或提高处理速率来解决问题，而是一个平衡的问题。在网络中一定有某些节点的缓存和处理速率与其他节点不匹配，当某个节点的缓存较小时，会丢弃一些新到的分组，而相应的主机会重传这些分组，甚至会重传多次，这样导致网络中的拥塞更加严重。因此解决拥塞问题通常采用的手段是改变网络的可用资源，或降低源头发送的数据量。拥塞控制的难处在于整个计算机网络是一个动态问题，需要监控拥塞发生的位置和数据源头，这本身就需要一定的开销（在节点之间交换信息和命令，用于选择合适的拥塞控制策略）。随着网络的复杂化和高速化，很容易出现节点缓存不足的情况，从而造成拥塞，并且有时候拥塞控制策略本身也会成为导致拥塞的原因。 目前解决拥塞问题的思想主要借鉴控制论的原理，分为开环控制和闭环控制。开环控制就是在设计网络时尽量全面的考虑可能出现的拥塞问题，在系统运行起来之后不再进行额外的干预；闭环控制则是在网络工作过程中，根据网络内部流量分布信息实时作出调整，通常有以下几种措施： 监测网络以便定位拥塞发生的位置和时间 将拥塞的信息发送到可以采取行动解决问题的地方（通常是信息的源头） 调整网络的运行以解决拥塞问题 几种具体的拥塞控制算法1999年因特网建议标准RFC2581定义了四种拥塞控制的算法：慢开始(slow start)，拥塞避免(congestion avoidance)，快重传(fast retransmit)，快恢复(fast recovery)。 慢开始核心思想是从较小的发送窗口开始，比如初始发送窗口设为一个MSS，随后从小到大增长到拥塞窗口的值。例如，先设发送窗口为一个MSS，在收到确认后增加为2个MSS，此后每收到一个确认分组就增加一个MSS。由于发送窗口内的数据连续发送，所以发送完一个窗口内的数据后，发送窗口的值会翻一倍，亦即拥塞窗口cwnd翻一倍。每经过一个传输轮次（发送完发送窗口内的所有数据并受到确认，为一个传输轮次），cwnd就翻一倍。这样cwnd相当于随着传输轮次成指数增长，因此慢开始并不是指增长速度慢，而是开始时发送窗口较小导致发送速率慢，其实cwnd的增长速率反而很快。 拥塞窗口cwnd不能无限增长，否则会引起拥塞。因此，需要设置阈值ssthresh，即慢开始门限，慢开始门限将cwnd划分出三个状态： cwnd &lt; ssthresh时，使用慢开始算法 cwnd &gt; ssthresh时，使用拥塞避免算法 cwnd = ssthresh时，以上两种算法二选一 其中拥塞避免算法是一种减缓cwnd增长的算法。 拥塞避免核心思想是让cwnd不随传输轮次的增加成指数增长，而是成线性增长。每经过一个传输轮次就将cwnd增加一个MSS。通常拥塞避免算法和慢开始配合使用。 如上图所示，不论在慢开始阶段还是拥塞避免阶段，只要网络中出现了拥塞现象，就将ssthresh减为原来的一半，然后将cwnd置为1，重新开始慢开始算法。这个过程也被称为“乘法减小”，即按1/2的比例缩小ssthresh。拥塞避免阶段也被称为“加法增大”，指cwnd的线性增长过程。 快重传快重传的核心思想是要求接收端在收到失序的报文段后立刻发送对最新按序报文段的确认，不能推迟捎带确认。跟非快重传方式相比（可以对失序报文什么也不做），快重传能够及时让发送端意识到报文的丢失，不必等到计时器到时再重传相应报文。快重传算法规定，如果发送端连续收到三个重复的确认，就认为有报文丢失（被确认的下一个报文），然后重新发送。 快恢复快恢复通常配合快重传一起使用。步骤如下： 发送端连续收到三个重复的确认后，执行“乘法减小”操作，将ssthresh减半。（丢失报文可能意味着网络状况变差） ssthresh减半后不降cwnd置为1个MSS，而是置为ssthresh，然后执行拥塞避免算法。因为三个连续的重复确认能够到达发送端，意味着可能没有阻塞。]]></content>
      <categories>
        <category>C++服务器</category>
      </categories>
      <tags>
        <tag>Newwork progamming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议的流量控控制]]></title>
    <url>%2F2019%2F03%2F28%2FTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[TCP协议的流量控控制为什么需要流量控制在TCP传输过程中，发送和接收速度受到缓存和网络情况的限制，如果发送过快，会造成数据丢失，降低信道利用率。流量控制就是将发送速率控制在合理范围内。 流量控制的实现流量控制的实现主要通过改变窗口的大小。如图所示： 此例中，接收端每次应答的时候都会更新接收窗口值，该窗口值随着接收端的剩余缓存空间而改变。在第4次应答时，将窗口值设为了0，意味着接收窗口已满。此后又有了缓存空间，于是将窗口更新为2000。假设该更新分组丢失，则发送端无法得知接收端又有了缓存空间，发送端也无法得知分组丢失，那么就会陷入死锁。在这种情况下，TCP为每个连接设立了持续计时器，当接到窗口更新为0的分组时，启动计时器，一段时间之后，发送端会发送一个探测报文段，该报文段仅携带一个字节。接收端收到探测报文段后会更新窗口值。如果仍是0，则发送端再次启动持续计时器。 流量控制与传输效率发送窗口中的数据不是简单连续发送的，而是要考虑信道上的传输效率。如果一则报文中的数据部分过短，会导致报头与数据部分比值过大，影响传输效率。所以有特定的机制来选择恰当的传输时机，保证较高的传输效率。第一种机制是由TCP维持一个最大报文长度MSS，当缓存中的数据达到MSS时就封装成一个TCP报文段发送出去；第二种机制是由发送方的应用进程指明发送报文段，即推送机制；第三种机制是使用计时器，每过一段时间就发送缓存中的已有数据。 在TCP协议中广泛使用的一种算法是Nagle算法。根据Nagle算法，若发送方将数据存入发送缓存，则先发送第一个字节，将后面到达的数据缓存起来。当接收方对第一个字节数据确认后，再将缓存中的所有数据封装为一个报文段发送，同时对后面到达的数据进行缓存。以后每收到一个确认就发送下一个报文段。Nagle还规定，当收到确认的数据占发送窗口的一半或全部时，立即发送下一个报文段，不需要等待确认。这样能进一步提高网络的吞吐量。 在Nagle的算法中可能会发生糊涂窗口问题。即假设接收方的缓存已满，此时接收方的应用进程只取走了很少的数据，接收窗口很小，此时向发送方发送了确认，发送方只能发送很少的数据到接收端，接收窗口又满了，陷入恶性循环，导致网络利用率很低。解决这个问题的方法是可以让接收方等待一定时间，使接收窗口有缓存的一半空闲空间或者足够容纳一个最长报文段MSS，就向发送方发送确认报文，开始正常的传输。此外，发送方发送的报文也不应该太小，应累积到MSS或者接收窗口的一半大小的数据再发送。]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>Network programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议中的滑窗协议（连续ARQ协议）]]></title>
    <url>%2F2019%2F03%2F28%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%BB%91%E7%AA%97%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP协议中的滑窗协议（连续ARQ协议）为什么需要滑动窗口协议（连续ARQ协议）TCP协议的滑窗协议的作用是提高信道利用率，同时在流量控制和拥塞管理中也会起到控制作用。根据TCP协议的停止等待协议，发送方在发送一个分组后需要等待接收方返回确认分组，在收到确认分组之后发送方才认为信息发送成功，否则根据超时重传机制重复发送。在这个过程中，如果发送方每发送一个分组就进入等待状态，则信道利用率会非常低，具体公式： U=\frac{T_{D}}{T_{D}+RTT+T_{A}}即发送分组时间与发送分组、平均往返时间和接受确认分组时间之和的比值。根据《计算机网络》的举例，假定1200km的传输距离，分组长度1200bit，传输速率1Mb/s， 则信道利用率约为5.66%，传输速率越高则利用率越低。因此，为了提高信道利用率，需要在发送分组和等待确认分组之间连续发送分组，而不是以空闲的状态等待。连续发送分组的数量受到发送方和接收方缓存空间和网络状态的影响，因此使用滑窗协议控制连续发送的字节数。 滑窗协议的工作方式基本过程滑动窗口的含义是：发送方维持一个可以连续发送的字节的序号，在序号范围内的字节可以连续发送，不需要等待确认分组；接收方维持一个已经接收到的字节的序号，对按顺序接收到的最高字节序号进行确认，并缓存未按序接收到的字节。因此，在滑窗协议的作用下，接收方不是对每个分组发送确认分组，而是采用累积确认的方式，对按序接受到的最后一个分组确认，表示此分组之前的所有分组都按序接收到了。这样做的好处是实现简单，缺点是不能反应已经接收到的分组的真实情况。如果发送方发送的分组中的第N个丢失，即使N之后分组被成功接收，也只能收到接收方对N-1和分组的确认，所以发送方需要重新发送从N开始的所有分组，即Go-back-N机制（回退N）。 具体过程对于发送方来说：发送窗口内的字节可以连续发送，不需要等待B的确认分组。同时已发送但未确认的数据都要保留，以备重新发送。发送窗口图示： 可以看见，在发送方窗口中，数据按照发送状态被分为四部分： 已发送且已收到确认 已发送但未收到确认 在发送窗口内但尚未发送 尚未进入发送窗口 对于接收方来说：对于接收窗口内的按序收到的最后一个字节发送确认分组给发送方，并且将按序收到的数据交付主机的进程，因此接收窗口中的数据主要包含非按序接收的字节和尚未交付主机进程的数据。接收窗口图示： 可以看见，在接收方窗口中，数据也可以按照接收状态分为四部分： 已收到并发送过确认分组且已交付主机进程 已收到但未交付主机或非按序字节 接收窗口中允许继续接收的部分 尚未进入接收窗口 根据图示可以看出发送窗口和接收窗口的变化过程，为了方便描述，设发送方为S(send),接收方为A(accept)。假设S发送窗口内的10个字节后，收到A对前5个字节的确认，此时发送窗口向前移动5个字节，相当于扩大了发送窗口中的可发送部分。此时如果第6个字节丢失或在网络中延迟，导致A没有收到它，而是先收到了第7个字节，则A无法对接下来收到的字节发送确认，因为A只能对按序收到的字节确认。S发送窗口中的数据继续发送，可发送区域不断缩小，直到发送窗口中都是已发送但未确认的字节，即发送窗口已满，且没有继续收到A的确认（缺失第6字节），则S必须停止发送。在超时重传机制的作用下，S经过一段时间后会重新发送从第6字节开始的数据，直到收到A的确认，然后继续滑动发送窗口，持续这个动态过程。在接收窗口中，如果检查出收到的分组有错误，则丢弃改分组。对于窗口的工作过程，还有一些要点： 发送窗口的大小是由接收方说明的，接收方会在TCP数据包的window字段，根据接收窗口的大小指明发送方可以设置的窗口大小。但是发送方的窗口大小不是每时每刻都保持与接收窗口一致。因为网络有延迟，接收方对窗口的调整信息可能不能及时传递到发送方，此外，发送窗口的大小还会根据网络的拥塞情况根据相应算法做调整。 TCP协议没有对已接收的无序字节的处理作出规定，通常是缓存在接收窗口中，等到缺失的字节到来后组成有序数据，再交付主机进程处理 TCP规定接收方必须有累积确认机制。接收端可以选择延迟确认，比如在需要发送数据时捎带上确认分组，但是推迟时间不能超过0.5秒。通常这种推迟确认的情况不会发生]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>Network Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reactor模式]]></title>
    <url>%2F2019%2F01%2F05%2FReactor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reactor模式实现I/O复用Reactor模式简介在网络服务器编程中，一个常见的实际场景是服务器需要与多个套接字连接，如果某个套接字可读，即读取该套接字数据并做相关处理。处理这样场景的最简单思路就是用非阻塞的read对所有套接字轮询，或者使用select和poll进行轮询。因为轮询需要持续查看内核中某个套接字是否就绪，如果连接了大量套接字则每次轮询时间会很长，不利于I/O密集型应用。epoll作为加强版的poll不会随着监听的套接字数量增长而大幅降低效率。epoll也是通常会使用的I/O复用模型，但是epoll作为linux系统调用过于底层，在实际使用中常常对其按照某种事件处理机制进一步封装。一种常用的事件处理机制工作方式如下描述： 服务器连接的套接字可以抽象为事件源，每个事件对应的处理函数可以抽象为事件处理器，在事件源和事件处理器之间需要一个事件分离器进行分配，将每个事件分配到对应的事件处理器中进行处理。事件分离器用epoll实现。应用程序事先在事件分离器中注册相应的事件处理器，当事件发生时，epoll将该事件分配到已注册的事件处理器中进行处理，由事件处理器完成实际的读写。这种事件处理机制就是Reactor模式。Reactor的核心在于以事件为驱动，而不是主动调用处理函数等待事件发生。在Reactor模式中，应用程序需要先注册好处理事件的接口，当事件发生时回调已经注册好的处理函数进行处理。这种被动调用的方式有如下优点： 响应速度快； 可扩展性强，能够方便的增加Reactor实例个数来充分利用CPU资源； 可复用性强，Reactor与具体的业务逻辑无关，只与I/O调度有关，具有很高的复用性； 编程简单，避免了多线程/多进程的切换开销。 Reactor模式组成 如图中所示，Reactor为时间反应器， Event Handler为时间处理器，Event Demultiplexer为时间分离器， Concrete Event Handler封装时间处理器， Handle为时间源。 事件源（handler）：一般是描述符，由操作系统提供。可以使socket，文件描述符等。可以来自系统内部，也可以来自系统内部； 事件反应器（Reactor）：是Reactor模式的核心，负责应用程序控制事件的调度。包括应用程序的注册，删除事件处理器和相关描述符的接口。它使用事件分离器等待事件的发生，事件发生时，事件分离器会回调事先注册好的回调函数来处理对应事件； 事件分离器（Event Demultiplexer）：一般由epoll实现，调用者会被阻塞直到事件分离器上注册的事件发生； 事件处理器（Event Handler）：提供了一组能够处理对应事件的接口，这组接口事先由应用程序注册。 Reactor事件处理流程首先是事件注册部分，应用程序将期待注册的套接字描述符作为事件源，将对应的回调函数和该描述符注册到事件处理器上，然后将该事件处理器注册到事件反应器上。事件反应器将注册信息再次注册到事件分离器epoll中，在epoll中通过epoll_ctl进行添加描述符及事件，并层层返回注册结果；然后是事件处理部分，事件反应器通过epoll_wait等待注册事件发生。一旦事件真的发生，epoll_wait将会返回，并将包含该事件的事件集返回到事件反应器，反应器根据事件源找到该事件的处理器，并根据事件类型调用之前在事件处理器中注册的回调函数，在回调函数中完成事件的处理。根据Reactor模式的具体流程可知，应用程序只参与了最初的注册步骤，具体的等待事件发生和事件处理都由Reactor分配。因此， 在Reactor模式中，应用程序无须关心事件的来源和发生时间，只要完成回调函数和描述符的注册即可，事件的处理流程被Reactor控制翻转了。这一特性对应了设计模式中的好莱坞原则。 Reactor的使用 在初始化阶段， 我们将服务器监听套接字及对应的处理函数注册到Reactor中，然后系统进入Reactor的大循环中等待事件的发生。接下来，如果发生监听套接字可读事件，则表示有新连接产生。Reactor回调之前注册好的回调函数，即通过accept系统调用获取新连接的套接字，并将该连接的描述符和对应的处理函数注册到Reactor中。执行完监听套接字的处理函数后，若仍有事件未处理，则继续进入该事件对应的回调函数中进行处理；否则进入下一次事件循环中，继续调用epoll阻塞等待事件的发生；这时，Reactor上已经注册了两类事件：监听套接字可读事件（代表新连接的产生）和连接套接字可读事件（代表有从客户端发来的数据）。在接下来的循环中，如果到达的事件是监听套接字事件，则重复上面的步骤；若到达的是连接套接字事件，则Reactor会回调对应的连接套接字Handler。在这次调用中，先通过read系统调用读取收到的数据，然后进行具体的处理。处理结束后若还有事件待处理，则继续处理，否则进入下次循环，epoll阻塞等待事件的发生。以上描述的是单线程中服务器使用Reactor模式建立新的客户端连接并接受、处理客户端数据的工作。Reactor满足了高并发和高性能的需求，同时实现了网络细节与业务逻辑的分离。在使用中只需要在不同事件对应的Handler中实现具体的业务逻辑即可。]]></content>
      <categories>
        <category>C++服务器设计</category>
      </categories>
      <tags>
        <tag>C++服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转载）C++虚函数表解析]]></title>
    <url>%2F2018%2F10%2F25%2F%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[C++ 虚函数表解析 &nbsp; 陈皓 http://blog.csdn.net/haoel &nbsp; &nbsp; 前言 &nbsp; C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 &nbsp; &nbsp; 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 &nbsp; 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 &nbsp; 言归正传，让我们一起进入虚函数的世界。 &nbsp; &nbsp; 虚函数表 &nbsp; 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 &nbsp; 这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 &nbsp; 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 &nbsp; 假设我们有这样的一个类： &nbsp; class Base { &nbsp;&nbsp;&nbsp;&nbsp; public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base::h" &lt;&lt; endl; } &nbsp; }; &nbsp; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef void(*Fun)(void); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base b; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "虚函数表地址：" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "虚函数表 — 第一个函数地址：" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Invoke the first virtual function&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)*((int*)*(int*)(&amp;b)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; 实际运行经果如下：(Windows XP+VS2003,&nbsp; Linux 2.6.22 + GCC 4.1.3) &nbsp; 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f &nbsp; &nbsp; 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+0);&nbsp; // Base::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+1);&nbsp; // Base::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Fun)*((int*)*(int*)(&amp;b)+2);&nbsp; // Base::h() &nbsp; 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： &lt;?xml:namespace prefix = v /&gt; 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 &nbsp; &nbsp; 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 &nbsp; 一般继承（无虚函数覆盖） &nbsp; 下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： &nbsp; &nbsp; 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示： &nbsp; 对于实例：Derive d; 的虚函数表如下： &nbsp; 我们可以看到下面几点： 1）虚函数按照其声明顺序放于表中。 2）父类的虚函数在子类的虚函数前面。 &nbsp; 我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 &nbsp; &nbsp; &nbsp; 一般继承（有虚函数覆盖） &nbsp; 覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 &nbsp; &nbsp; &nbsp; 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： &nbsp; &nbsp; 我们从表中可以看到下面几点， 1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 2）没有被覆盖的函数依旧。 &nbsp; 这样，我们就可以看到对于下面这样的程序， &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base *b = new Derive(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;f(); &nbsp; 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 &nbsp; &nbsp; &nbsp; 多重继承（无虚函数覆盖） &nbsp; 下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 &nbsp; &nbsp; &nbsp; 对于子类实例中的虚函数表，是下面这个样子： &nbsp; 我们可以看到： 1）&nbsp; 每个父类都有自己的虚表。 2）&nbsp; 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） &nbsp; 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 &nbsp; &nbsp; &nbsp; &nbsp; 多重继承（有虚函数覆盖） &nbsp; 下面我们再来看看，如果发生虚函数覆盖的情况。 &nbsp; 下图中，我们在子类中覆盖了父类的f()函数。 &nbsp; &nbsp; &nbsp; 下面是对于子类实例中的虚函数表的图： &nbsp; &nbsp; 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 *b1 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base2 *b2 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base3 *b3 = &amp;d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f(); //Derive::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;f(); //Derive::f() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;f(); //Derive::f() &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;g(); //Base1::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2-&gt;g(); //Base2::g() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3-&gt;g(); //Base3::g() &nbsp; &nbsp; 安全性 &nbsp; 每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 &nbsp; 一、通过父类型的指针访问子类自己的虚函数 我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1 *b1 = new Derive(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1-&gt;f1();&nbsp; //编译出错 &nbsp; 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） &nbsp; &nbsp; 二、访问non-public的虚函数 另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 &nbsp; 如： &nbsp; class Base { &nbsp;&nbsp;&nbsp; private: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } &nbsp; }; &nbsp; class Derive : public Base{ &nbsp; }; &nbsp; typedef void(*Fun)(void); &nbsp; void main() { &nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp; Fun&nbsp; pFun = (Fun)*((int*)*(int*)(&amp;d)+0); &nbsp;&nbsp;&nbsp; pFun(); } &nbsp; &nbsp; 结束语 C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 &nbsp; 在文章束之前还是介绍一下自己吧。我从事软件研发有十个年头了，目前是软件开发技术主管，技术方面，主攻Unix/C/C++，比较喜欢网络上的技术，比如分布式计算，网格计算，P2P，Ajax等一切和互联网相关的东西。管理方面比较擅长于团队建设，技术趋势分析，项目管理。欢迎大家和我交流，我的MSN和Email是：haoel@hotmail.com&nbsp; &nbsp; 附录一：VC中查看虚函数表 &nbsp; 我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的） 附录 二：例程 下面是一个关于多重继承的虚函数表访问的例程： &nbsp; #include &lt;iostream&gt; using namespace std; &nbsp; class Base1 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base1::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base1::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base1::h" &lt;&lt; endl; } &nbsp; }; &nbsp; class Base2 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base2::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base2::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base2::h" &lt;&lt; endl; } }; &nbsp; class Base3 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Base3::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g() { cout &lt;&lt; "Base3::g" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void h() { cout &lt;&lt; "Base3::h" &lt;&lt; endl; } }; &nbsp; &nbsp; class Derive : public Base1, public Base2, public Base3 { public: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() { cout &lt;&lt; "Derive::f" &lt;&lt; endl; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g1() { cout &lt;&lt; "Derive::g1" &lt;&lt; endl; } }; &nbsp; &nbsp; typedef void(*Fun)(void); &nbsp; int main() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun pFun = NULL; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Derive d; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int** pVtab = (int**)&amp;d; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base1's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Derive's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[0][4]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base2's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[1][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Base3's vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][2]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun(); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The tail of the vtable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFun = (Fun)pVtab[2][3]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;pFun&lt;&lt;endl; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; } &nbsp; (转载时请注明作者和出处。未经许可，请勿用于商业用途) &nbsp; 更多文章请访问我的Blog: http://blog.csdn.net/haoel &nbsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++中的int, long, long long]]></title>
    <url>%2F2018%2F10%2F24%2FC-%E4%B8%AD%E7%9A%84int-long-long-long%2F</url>
    <content type="text"><![CDATA[C++中的int, long, long longC++中的三种整数数据类型，int， long， long long是平时极为常用的类型，在此总结一下它们的用法。 int， long，和long long之间可以隐式转换，规则为从取值范围小到取值范围大的转换，例如int&gt;long 三者占用的空间，根据《C++ primer》算数类型的尺寸根据不同的机器和编译器会有所差别。C++只规定了最小尺寸，允许编译器赋予更大的尺寸。 类型 最小尺寸 short 16位 int 16位 long 32位 long long 64位 C++语言规定int至少和short一样大，long至少和int一样大， long long 至少和long一样大。其中long long是C++11中新定义的。通常来讲，short是半个机器字长，int是一个机器字长， long是一到两个机器字长， long long在任何环境下都是8个字节。 一般情况下，32位系统中short为2个字节，int为4个字节，long与int相同为4个字节， long long为8个字节；64位系统中short依然为2个字节，为了向前兼容，int也会被编译为4个字节，long为8个字节，long long为8个字节。 所以在实际使用中，不同的编译器对算数类型的处理可能会有差别，在不同系统和编译器中得到的算数类型尺寸不一定相同，除了short是稳定的2个字节，以及long long是稳定的8个字节。所以在需要获取算数类型尺寸的时候最好用sizeof()， 而不是凭经验认定int就是4个字节或long就是8个字节, 实际上long与int尺寸相同的情况很常见。需要扩大尺寸的话尽量用long long，可以保证是8个字节。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列]]></title>
    <url>%2F2018%2F08%2F23%2FLeetcode-Dynamic-Programming-Best-Time-to-Buy-and-Sell-Stock%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Leetcode-Dynamic Programming: Best Time to Buy and Sell Stock系列 Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 这是买卖股票问题系列中最简单的一道，求只买卖一次股票的获利最大值。即找到数组中某一项与该项后面某一项的差值为数组中最大的差值。初始化变量res用来存储利润，在遍历价格的过程中更新前n项中的最小值buy，每次计算当前值与buy之间的差，将res更新为当前差值与原利润间的最大值即可。遍历完成则res为所求结果。 C++ 123456789101112class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, buy = INT_MAX; for(int price:prices) &#123; buy = min(buy, price); res = max(price - buy, res); &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 本题有两种思路。 第一种：既然可以多次买卖，那么只要保证每次均低价买入高价卖出即可。也就是说次日售价高于当日售价则当日不会卖出，直到次日售价小于等于当日售价才会卖出，所以每次买卖的利润等于买入日期和卖出日期之间的每两日价格差的和。依次规则遍历数组，得到的利润和即为最终答案。 C++ 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0, n = prices.size(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res += prices[i + 1] - prices[i]; &#125; &#125; return res; &#125;&#125;; 第二种：将买卖股票的过程分为两个状态：刚买完prebuy和刚卖完presell，即手中持有股票和不持有股票两个状态。在持有股票的时候，下一个动作是卖，即在下一次买的时候获得的利润是已有利润减去当前价格。在不持有股票的时候，下一个动作是买，即在下一次卖的时候获得的利润是已有利润加上当前价格。将买卖股票的过程分两个状态单独考虑，好处在于更有普遍意义，在解买卖股票III和买卖股票IV以及cooldown时有体现。最终结果为最后一次卖所得利润。 C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, sell = 0; int prebuy = 0, presell = 0; for(int price : prices) &#123; prebuy = buy; presell = sell; buy = max(presell - price, prebuy); sell = max(prebuy + price, presell); &#125; int res = sell; return res; &#125;&#125;; Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 感觉这道题目解法不是很好理解，参考Grandyang的解法理解了很久。在这道题的思路中，实际上是将最多买k次（k小于总天数）的利润特例化为2次。这道题依然是动态规划的思想，用”局部最优和全局最优”的思想，维护两个递推式:前i天进行j次交易获得的全局最大利润global[i][j],以及前i天进行j次交易获得的局部最大利润local[i][j]。其中局部最大利润local[i][j]的含义是最后一次卖出发生在第i天的情况下前i天的最大利润。本题的最优子结构就是第i+1天的全局最优是前i天的全局最优与第i+1天的局部最优的最大值。递推式为 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit); global[i][j] = max(global[i-1][j], local[i][j]); 全局最优的含义比较简单，就是前i-1天的全局最优与前i天的局部最优取最大值。局部最优的含义为，前i-1天交易j-1次的全局最优与前i天的局部最优取最大值。因为第i天的局部最优是在第i天卖出的，若第i天售价高于i-1天，那么i-1天不卖，改在第i天卖就得到局部最优候选值；或者是前i-1天交易j-1次的全局最优，在第j-1次交易后在买一次，并在第i天卖出，得到局部最优的候选值。其中值得注意的是，在 local[i][j] = max(global[i-1][j-1]+profit, local[i-1][j]+profit) 中，profit是当天与前一天的价格差。因为global[i-1][j-1]一定是在第i-1天或之前卖出的，并且最后一次交易一定是在第i天卖出，所以profit不用考虑为负值的情况。local[i-1][j]也是如此。 因为需要遍历股票存在的天数和买卖次数，对k次交易来说时间复杂度为o(n^k)；当k=2时， 为o(n^2)。 C++ 123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) &#123; return 0; &#125; int n = prices.size(); int g[n][3] = &#123;0&#125;, l[n][3] = &#123;0&#125;; for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = 1; j &lt;= 2; ++j) &#123; l[i][j] = max(g[i-1][j-1] + diff, l[i-1][j] + diff); //由局部的极值推导全局最值 g[i][j] = max(g[i-1][j], l[i][j]); &#125; &#125; return g[n-1][2]; &#125;&#125;; 下面是用一维数值替代上面的二维数组，即global和local都用一维数组表示。能够极大节省空间。因为每次计算local都会使用前一天的global[j-1]，所以会产生覆盖问题，所以在交易次数的遍历中需要从2到1循环，避免覆盖。代码参考自Grandyang C++ 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if (prices.empty()) return 0; int g[3] = &#123;0&#125;; int l[3] = &#123;0&#125;; for (int i = 0; i &lt; prices.size() - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; for (int j = 2; j &gt;= 1; --j) &#123; l[j] = max(g[j - 1] + diff, l[j] + diff); g[j] = max(l[j], g[j]); &#125; &#125; return g[2]; &#125;&#125;; 在leetcode实际测试中，用二维数组的方法因为空间太大不能通过，只有第二种能够通过。 Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 这道题是III的一般化，思路与III相同。需要注意的是，在交易次数k大于股票存在天数时，问题退化为II，即不限交易次数的问题如果只用&quot;局部最优与全局最优的方法&quot;时间空间复杂度都会超限制。 C++ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 1||prices.empty() ||k == 0) &#123; return 0; &#125; if(k &gt;= prices.size()) &#123; return maxProfit_1(prices); &#125; int n = prices.size(); vector&lt;int&gt; g(k+1, 0); vector&lt;int&gt; l(k+1, 0); for(int i = 1; i &lt; n; ++i) &#123; int diff = prices[i] - prices[i-1]; for(int j = k; j &gt;=1; --j) &#123; l[j] = max(g[j-1]+diff, l[j]+diff); g[j] = max(g[j], l[j]); &#125; &#125; return g[k]; &#125; int maxProfit_1(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int n = prices.size(); for(int i = 1; i &lt; n; ++i) &#123; if(prices[i] &gt;prices[i-1]) &#123; res += (prices[i] - prices[i-1]); &#125; &#125; return res; &#125;&#125;; Best Time to Buy and Sell Stock with CooldownSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 这道题很有难度，同样是用dynamic programming思想，但是cooldown的加入使问题变得复杂。正如在II中提到的第二种思路，这道题需要将交易过程分为三个状态。即刚买完，刚卖完，以及刚刚cooldown。参考Grandyang的方法，维护三个数组buy[],sell[]和rest[]。 其中，buy[i]表示第i天之前的最后一个操作是买，即刚买完状态，后的最大利润。sell[i]表示刚卖完后的最大利润。rest[i]表示第i天前的最后一个操作是冷冻期的最大利润。 递推式为： buy[i] = max(rest[i-1]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); rest[i] = max(buy[i-1], sell[i-1], rest[i-1]); 上面的递推式表达出了买，卖，冷冻期的顺序。其中rest[i]可以简化。根据第一条递推式，rest[i] &gt;= buy[i]，所以 rest[i] = max(sell[i-1], rest[i-1]); 此外，根据交易顺序，rest在sell之后，buy之前，所以实际上rest[i] = sell[i-1]。所以递推式可以简化为 buy[i] = max(sell[i-2]-price, buy[i-1]); sell[i] = max(buy[i-1]+price, sell[i-1]); 可以看出递推式只依赖i-1和i-2项，所以能够实现空间复杂度o(1)的代码。 C++ 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy = INT_MIN, pre_buy = 0, sell = 0, pre_sell = 0; for (int price : prices) &#123; pre_buy = buy; buy = max(pre_sell - price, pre_buy); pre_sell = sell; sell = max(pre_buy + price, pre_sell); &#125; return sell; &#125;&#125;; 以上就是leetcode中股票交易的五道问题。前两道较容易，后三道使用动态规划思想，并且要想到局部最优与全局最优的关系，还是很有难度的。最后一题分状态列递推式的想法十分巧妙，在建模的思想上给我很大启发。[Grandyang](http://www.cnblogs.com/grandyang/p/4281975.html)的博客给我提供了很大帮助。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
</search>
